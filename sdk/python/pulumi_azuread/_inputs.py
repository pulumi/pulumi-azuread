# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AccessPackageAssignmentPolicyApprovalSettingsArgs',
    'AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs',
    'AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs',
    'AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs',
    'AccessPackageAssignmentPolicyAssignmentReviewSettingsArgs',
    'AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs',
    'AccessPackageAssignmentPolicyQuestionArgs',
    'AccessPackageAssignmentPolicyQuestionChoiceArgs',
    'AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs',
    'AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs',
    'AccessPackageAssignmentPolicyQuestionTextArgs',
    'AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs',
    'AccessPackageAssignmentPolicyRequestorSettingsArgs',
    'AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs',
    'ApplicationApiArgs',
    'ApplicationApiOauth2PermissionScopeArgs',
    'ApplicationAppRoleArgs',
    'ApplicationFeatureTagArgs',
    'ApplicationOptionalClaimsArgs',
    'ApplicationOptionalClaimsAccessTokenArgs',
    'ApplicationOptionalClaimsIdTokenArgs',
    'ApplicationOptionalClaimsSaml2TokenArgs',
    'ApplicationPublicClientArgs',
    'ApplicationRequiredResourceAccessArgs',
    'ApplicationRequiredResourceAccessResourceAccessArgs',
    'ApplicationSinglePageApplicationArgs',
    'ApplicationWebArgs',
    'ApplicationWebImplicitGrantArgs',
    'ConditionalAccessPolicyConditionsArgs',
    'ConditionalAccessPolicyConditionsApplicationsArgs',
    'ConditionalAccessPolicyConditionsClientApplicationsArgs',
    'ConditionalAccessPolicyConditionsDevicesArgs',
    'ConditionalAccessPolicyConditionsDevicesFilterArgs',
    'ConditionalAccessPolicyConditionsLocationsArgs',
    'ConditionalAccessPolicyConditionsPlatformsArgs',
    'ConditionalAccessPolicyConditionsUsersArgs',
    'ConditionalAccessPolicyGrantControlsArgs',
    'ConditionalAccessPolicySessionControlsArgs',
    'CustomDirectoryRolePermissionArgs',
    'GroupDynamicMembershipArgs',
    'InvitationMessageArgs',
    'NamedLocationCountryArgs',
    'NamedLocationIpArgs',
    'ServicePrincipalAppRoleArgs',
    'ServicePrincipalFeatureArgs',
    'ServicePrincipalFeatureTagArgs',
    'ServicePrincipalOauth2PermissionScopeArgs',
    'ServicePrincipalSamlSingleSignOnArgs',
    'SynchronizationJobScheduleArgs',
    'SynchronizationSecretCredentialArgs',
]

@pulumi.input_type
class AccessPackageAssignmentPolicyApprovalSettingsArgs:
    def __init__(__self__, *,
                 approval_required: Optional[pulumi.Input[bool]] = None,
                 approval_required_for_extension: Optional[pulumi.Input[bool]] = None,
                 approval_stages: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs']]]] = None,
                 requestor_justification_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] approval_required: Whether an approval is required.
        :param pulumi.Input[bool] approval_required_for_extension: Whether an approval is required to grant extension. Same approval settings used to approve initial access will apply.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs']]] approval_stages: An `approval_stage` block specifying the process to obtain an approval, as documented below.
        :param pulumi.Input[bool] requestor_justification_required: Whether a requestor is required to provide a justification to request an access package. Justification is visible to approvers and the requestor.
        """
        AccessPackageAssignmentPolicyApprovalSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            approval_required=approval_required,
            approval_required_for_extension=approval_required_for_extension,
            approval_stages=approval_stages,
            requestor_justification_required=requestor_justification_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             approval_required: Optional[pulumi.Input[bool]] = None,
             approval_required_for_extension: Optional[pulumi.Input[bool]] = None,
             approval_stages: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs']]]] = None,
             requestor_justification_required: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if approval_required is not None:
            _setter("approval_required", approval_required)
        if approval_required_for_extension is not None:
            _setter("approval_required_for_extension", approval_required_for_extension)
        if approval_stages is not None:
            _setter("approval_stages", approval_stages)
        if requestor_justification_required is not None:
            _setter("requestor_justification_required", requestor_justification_required)

    @property
    @pulumi.getter(name="approvalRequired")
    def approval_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether an approval is required.
        """
        return pulumi.get(self, "approval_required")

    @approval_required.setter
    def approval_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "approval_required", value)

    @property
    @pulumi.getter(name="approvalRequiredForExtension")
    def approval_required_for_extension(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether an approval is required to grant extension. Same approval settings used to approve initial access will apply.
        """
        return pulumi.get(self, "approval_required_for_extension")

    @approval_required_for_extension.setter
    def approval_required_for_extension(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "approval_required_for_extension", value)

    @property
    @pulumi.getter(name="approvalStages")
    def approval_stages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs']]]]:
        """
        An `approval_stage` block specifying the process to obtain an approval, as documented below.
        """
        return pulumi.get(self, "approval_stages")

    @approval_stages.setter
    def approval_stages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs']]]]):
        pulumi.set(self, "approval_stages", value)

    @property
    @pulumi.getter(name="requestorJustificationRequired")
    def requestor_justification_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a requestor is required to provide a justification to request an access package. Justification is visible to approvers and the requestor.
        """
        return pulumi.get(self, "requestor_justification_required")

    @requestor_justification_required.setter
    def requestor_justification_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "requestor_justification_required", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs:
    def __init__(__self__, *,
                 approval_timeout_in_days: pulumi.Input[int],
                 alternative_approval_enabled: Optional[pulumi.Input[bool]] = None,
                 alternative_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs']]]] = None,
                 approver_justification_required: Optional[pulumi.Input[bool]] = None,
                 enable_alternative_approval_in_days: Optional[pulumi.Input[int]] = None,
                 primary_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs']]]] = None):
        """
        :param pulumi.Input[int] approval_timeout_in_days: Maximum number of days within which a request must be approved. If a request is not approved within this time period after it is made, it will be automatically rejected.
        :param pulumi.Input[bool] alternative_approval_enabled: Whether alternative approvers are enabled.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs']]] alternative_approvers: A block specifying alternative approvers when escalation is enabled and the primary approvers do not respond before the escalation time, as documented below.
        :param pulumi.Input[bool] approver_justification_required: Whether an approver must provide a justification for their decision. Justification is visible to other approvers and the requestor.
        :param pulumi.Input[int] enable_alternative_approval_in_days: Number of days before the request is forwarded to alternative approvers.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs']]] primary_approvers: A block specifying the users who will be asked to approve requests, as documented below.
        """
        AccessPackageAssignmentPolicyApprovalSettingsApprovalStageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            approval_timeout_in_days=approval_timeout_in_days,
            alternative_approval_enabled=alternative_approval_enabled,
            alternative_approvers=alternative_approvers,
            approver_justification_required=approver_justification_required,
            enable_alternative_approval_in_days=enable_alternative_approval_in_days,
            primary_approvers=primary_approvers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             approval_timeout_in_days: pulumi.Input[int],
             alternative_approval_enabled: Optional[pulumi.Input[bool]] = None,
             alternative_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs']]]] = None,
             approver_justification_required: Optional[pulumi.Input[bool]] = None,
             enable_alternative_approval_in_days: Optional[pulumi.Input[int]] = None,
             primary_approvers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("approval_timeout_in_days", approval_timeout_in_days)
        if alternative_approval_enabled is not None:
            _setter("alternative_approval_enabled", alternative_approval_enabled)
        if alternative_approvers is not None:
            _setter("alternative_approvers", alternative_approvers)
        if approver_justification_required is not None:
            _setter("approver_justification_required", approver_justification_required)
        if enable_alternative_approval_in_days is not None:
            _setter("enable_alternative_approval_in_days", enable_alternative_approval_in_days)
        if primary_approvers is not None:
            _setter("primary_approvers", primary_approvers)

    @property
    @pulumi.getter(name="approvalTimeoutInDays")
    def approval_timeout_in_days(self) -> pulumi.Input[int]:
        """
        Maximum number of days within which a request must be approved. If a request is not approved within this time period after it is made, it will be automatically rejected.
        """
        return pulumi.get(self, "approval_timeout_in_days")

    @approval_timeout_in_days.setter
    def approval_timeout_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "approval_timeout_in_days", value)

    @property
    @pulumi.getter(name="alternativeApprovalEnabled")
    def alternative_approval_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether alternative approvers are enabled.
        """
        return pulumi.get(self, "alternative_approval_enabled")

    @alternative_approval_enabled.setter
    def alternative_approval_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "alternative_approval_enabled", value)

    @property
    @pulumi.getter(name="alternativeApprovers")
    def alternative_approvers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs']]]]:
        """
        A block specifying alternative approvers when escalation is enabled and the primary approvers do not respond before the escalation time, as documented below.
        """
        return pulumi.get(self, "alternative_approvers")

    @alternative_approvers.setter
    def alternative_approvers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs']]]]):
        pulumi.set(self, "alternative_approvers", value)

    @property
    @pulumi.getter(name="approverJustificationRequired")
    def approver_justification_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether an approver must provide a justification for their decision. Justification is visible to other approvers and the requestor.
        """
        return pulumi.get(self, "approver_justification_required")

    @approver_justification_required.setter
    def approver_justification_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "approver_justification_required", value)

    @property
    @pulumi.getter(name="enableAlternativeApprovalInDays")
    def enable_alternative_approval_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days before the request is forwarded to alternative approvers.
        """
        return pulumi.get(self, "enable_alternative_approval_in_days")

    @enable_alternative_approval_in_days.setter
    def enable_alternative_approval_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "enable_alternative_approval_in_days", value)

    @property
    @pulumi.getter(name="primaryApprovers")
    def primary_approvers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs']]]]:
        """
        A block specifying the users who will be asked to approve requests, as documented below.
        """
        return pulumi.get(self, "primary_approvers")

    @primary_approvers.setter
    def primary_approvers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs']]]]):
        pulumi.set(self, "primary_approvers", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs:
    def __init__(__self__, *,
                 subject_type: pulumi.Input[str],
                 backup: Optional[pulumi.Input[bool]] = None,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject_type: Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        :param pulumi.Input[bool] backup: For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        :param pulumi.Input[str] object_id: The ID of the subject.
        """
        AccessPackageAssignmentPolicyApprovalSettingsApprovalStageAlternativeApproverArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_type=subject_type,
            backup=backup,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_type: pulumi.Input[str],
             backup: Optional[pulumi.Input[bool]] = None,
             object_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subject_type", subject_type)
        if backup is not None:
            _setter("backup", backup)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subject.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs:
    def __init__(__self__, *,
                 subject_type: pulumi.Input[str],
                 backup: Optional[pulumi.Input[bool]] = None,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject_type: Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        :param pulumi.Input[bool] backup: For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        :param pulumi.Input[str] object_id: The ID of the subject.
        """
        AccessPackageAssignmentPolicyApprovalSettingsApprovalStagePrimaryApproverArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_type=subject_type,
            backup=backup,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_type: pulumi.Input[str],
             backup: Optional[pulumi.Input[bool]] = None,
             object_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subject_type", subject_type)
        if backup is not None:
            _setter("backup", backup)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subject.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyAssignmentReviewSettingsArgs:
    def __init__(__self__, *,
                 access_recommendation_enabled: Optional[pulumi.Input[bool]] = None,
                 access_review_timeout_behavior: Optional[pulumi.Input[str]] = None,
                 approver_justification_required: Optional[pulumi.Input[bool]] = None,
                 duration_in_days: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 review_frequency: Optional[pulumi.Input[str]] = None,
                 review_type: Optional[pulumi.Input[str]] = None,
                 reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs']]]] = None,
                 starting_on: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] access_recommendation_enabled: Whether to show the reviewer decision helpers. If enabled, system recommendations based on users' access information will be shown to the reviewers. The reviewer will be recommended to approve the review if the user has signed-in at least once during the last 30 days. The reviewer will be recommended to deny the review if the user has not signed-in during the last 30 days.
        :param pulumi.Input[str] access_review_timeout_behavior: Specifies the actions the system takes if reviewers don't respond in time. Valid values are `keepAccess`, `removeAccess`, or `acceptAccessRecommendation`.
        :param pulumi.Input[bool] approver_justification_required: Whether a reviewer needs to provide a justification for their decision. Justification is visible to other reviewers and the requestor.
        :param pulumi.Input[int] duration_in_days: How many days each occurrence of the access review series will run.
        :param pulumi.Input[bool] enabled: Whether to enable assignment review.
        :param pulumi.Input[str] review_frequency: This will determine how often the access review campaign runs, valid values are `weekly`, `monthly`, `quarterly`, `halfyearly`, or `annual`.
        :param pulumi.Input[str] review_type: Self-review or specific reviewers. Valid values are `Manager`, `Reviewers`, or `Self`.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs']]] reviewers: One or more `reviewer` blocks to specify the users who will be reviewers (when `review_type` is `Reviewers`), as documented below.
        :param pulumi.Input[str] starting_on: This is the date the access review campaign will start on, formatted as an RFC3339 date string in UTC(e.g. 2018-01-01T01:02:03Z), default is now. Once an access review has been created, you cannot update its start date
        """
        AccessPackageAssignmentPolicyAssignmentReviewSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_recommendation_enabled=access_recommendation_enabled,
            access_review_timeout_behavior=access_review_timeout_behavior,
            approver_justification_required=approver_justification_required,
            duration_in_days=duration_in_days,
            enabled=enabled,
            review_frequency=review_frequency,
            review_type=review_type,
            reviewers=reviewers,
            starting_on=starting_on,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_recommendation_enabled: Optional[pulumi.Input[bool]] = None,
             access_review_timeout_behavior: Optional[pulumi.Input[str]] = None,
             approver_justification_required: Optional[pulumi.Input[bool]] = None,
             duration_in_days: Optional[pulumi.Input[int]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             review_frequency: Optional[pulumi.Input[str]] = None,
             review_type: Optional[pulumi.Input[str]] = None,
             reviewers: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs']]]] = None,
             starting_on: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_recommendation_enabled is not None:
            _setter("access_recommendation_enabled", access_recommendation_enabled)
        if access_review_timeout_behavior is not None:
            _setter("access_review_timeout_behavior", access_review_timeout_behavior)
        if approver_justification_required is not None:
            _setter("approver_justification_required", approver_justification_required)
        if duration_in_days is not None:
            _setter("duration_in_days", duration_in_days)
        if enabled is not None:
            _setter("enabled", enabled)
        if review_frequency is not None:
            _setter("review_frequency", review_frequency)
        if review_type is not None:
            _setter("review_type", review_type)
        if reviewers is not None:
            _setter("reviewers", reviewers)
        if starting_on is not None:
            _setter("starting_on", starting_on)

    @property
    @pulumi.getter(name="accessRecommendationEnabled")
    def access_recommendation_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to show the reviewer decision helpers. If enabled, system recommendations based on users' access information will be shown to the reviewers. The reviewer will be recommended to approve the review if the user has signed-in at least once during the last 30 days. The reviewer will be recommended to deny the review if the user has not signed-in during the last 30 days.
        """
        return pulumi.get(self, "access_recommendation_enabled")

    @access_recommendation_enabled.setter
    def access_recommendation_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_recommendation_enabled", value)

    @property
    @pulumi.getter(name="accessReviewTimeoutBehavior")
    def access_review_timeout_behavior(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the actions the system takes if reviewers don't respond in time. Valid values are `keepAccess`, `removeAccess`, or `acceptAccessRecommendation`.
        """
        return pulumi.get(self, "access_review_timeout_behavior")

    @access_review_timeout_behavior.setter
    def access_review_timeout_behavior(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_review_timeout_behavior", value)

    @property
    @pulumi.getter(name="approverJustificationRequired")
    def approver_justification_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a reviewer needs to provide a justification for their decision. Justification is visible to other reviewers and the requestor.
        """
        return pulumi.get(self, "approver_justification_required")

    @approver_justification_required.setter
    def approver_justification_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "approver_justification_required", value)

    @property
    @pulumi.getter(name="durationInDays")
    def duration_in_days(self) -> Optional[pulumi.Input[int]]:
        """
        How many days each occurrence of the access review series will run.
        """
        return pulumi.get(self, "duration_in_days")

    @duration_in_days.setter
    def duration_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_days", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable assignment review.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="reviewFrequency")
    def review_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        This will determine how often the access review campaign runs, valid values are `weekly`, `monthly`, `quarterly`, `halfyearly`, or `annual`.
        """
        return pulumi.get(self, "review_frequency")

    @review_frequency.setter
    def review_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "review_frequency", value)

    @property
    @pulumi.getter(name="reviewType")
    def review_type(self) -> Optional[pulumi.Input[str]]:
        """
        Self-review or specific reviewers. Valid values are `Manager`, `Reviewers`, or `Self`.
        """
        return pulumi.get(self, "review_type")

    @review_type.setter
    def review_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "review_type", value)

    @property
    @pulumi.getter
    def reviewers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs']]]]:
        """
        One or more `reviewer` blocks to specify the users who will be reviewers (when `review_type` is `Reviewers`), as documented below.
        """
        return pulumi.get(self, "reviewers")

    @reviewers.setter
    def reviewers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs']]]]):
        pulumi.set(self, "reviewers", value)

    @property
    @pulumi.getter(name="startingOn")
    def starting_on(self) -> Optional[pulumi.Input[str]]:
        """
        This is the date the access review campaign will start on, formatted as an RFC3339 date string in UTC(e.g. 2018-01-01T01:02:03Z), default is now. Once an access review has been created, you cannot update its start date
        """
        return pulumi.get(self, "starting_on")

    @starting_on.setter
    def starting_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starting_on", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs:
    def __init__(__self__, *,
                 subject_type: pulumi.Input[str],
                 backup: Optional[pulumi.Input[bool]] = None,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject_type: Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        :param pulumi.Input[bool] backup: For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        :param pulumi.Input[str] object_id: The ID of the subject.
        """
        AccessPackageAssignmentPolicyAssignmentReviewSettingsReviewerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_type=subject_type,
            backup=backup,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_type: pulumi.Input[str],
             backup: Optional[pulumi.Input[bool]] = None,
             object_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subject_type", subject_type)
        if backup is not None:
            _setter("backup", backup)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subject.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['AccessPackageAssignmentPolicyQuestionTextArgs'],
                 choices: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceArgs']]]] = None,
                 required: Optional[pulumi.Input[bool]] = None,
                 sequence: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['AccessPackageAssignmentPolicyQuestionTextArgs'] text: A block describing the content of this question, as documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceArgs']]] choices: One or more blocks configuring a choice to the question, as documented below.
        :param pulumi.Input[bool] required: Whether this question is required.
        :param pulumi.Input[int] sequence: The sequence number of this question.
        """
        AccessPackageAssignmentPolicyQuestionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
            choices=choices,
            required=required,
            sequence=sequence,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: pulumi.Input['AccessPackageAssignmentPolicyQuestionTextArgs'],
             choices: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceArgs']]]] = None,
             required: Optional[pulumi.Input[bool]] = None,
             sequence: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("text", text)
        if choices is not None:
            _setter("choices", choices)
        if required is not None:
            _setter("required", required)
        if sequence is not None:
            _setter("sequence", sequence)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['AccessPackageAssignmentPolicyQuestionTextArgs']:
        """
        A block describing the content of this question, as documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['AccessPackageAssignmentPolicyQuestionTextArgs']):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def choices(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceArgs']]]]:
        """
        One or more blocks configuring a choice to the question, as documented below.
        """
        return pulumi.get(self, "choices")

    @choices.setter
    def choices(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceArgs']]]]):
        pulumi.set(self, "choices", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this question is required.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def sequence(self) -> Optional[pulumi.Input[int]]:
        """
        The sequence number of this question.
        """
        return pulumi.get(self, "sequence")

    @sequence.setter
    def sequence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sequence", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionChoiceArgs:
    def __init__(__self__, *,
                 actual_value: pulumi.Input[str],
                 display_value: pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs']):
        """
        :param pulumi.Input[str] actual_value: The actual value of this choice.
        :param pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs'] display_value: A block describing the display text of this choice, as documented below.
        """
        AccessPackageAssignmentPolicyQuestionChoiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actual_value=actual_value,
            display_value=display_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actual_value: pulumi.Input[str],
             display_value: pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actual_value", actual_value)
        _setter("display_value", display_value)

    @property
    @pulumi.getter(name="actualValue")
    def actual_value(self) -> pulumi.Input[str]:
        """
        The actual value of this choice.
        """
        return pulumi.get(self, "actual_value")

    @actual_value.setter
    def actual_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "actual_value", value)

    @property
    @pulumi.getter(name="displayValue")
    def display_value(self) -> pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs']:
        """
        A block describing the display text of this choice, as documented below.
        """
        return pulumi.get(self, "display_value")

    @display_value.setter
    def display_value(self, value: pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs']):
        pulumi.set(self, "display_value", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs:
    def __init__(__self__, *,
                 default_text: pulumi.Input[str],
                 localized_texts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs']]]] = None):
        """
        :param pulumi.Input[str] default_text: The default text of this question choice.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs']]] localized_texts: One or more blocks describing localized text of this question choice, as documented below.
        """
        AccessPackageAssignmentPolicyQuestionChoiceDisplayValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_text=default_text,
            localized_texts=localized_texts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_text: pulumi.Input[str],
             localized_texts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_text", default_text)
        if localized_texts is not None:
            _setter("localized_texts", localized_texts)

    @property
    @pulumi.getter(name="defaultText")
    def default_text(self) -> pulumi.Input[str]:
        """
        The default text of this question choice.
        """
        return pulumi.get(self, "default_text")

    @default_text.setter
    def default_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_text", value)

    @property
    @pulumi.getter(name="localizedTexts")
    def localized_texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs']]]]:
        """
        One or more blocks describing localized text of this question choice, as documented below.
        """
        return pulumi.get(self, "localized_texts")

    @localized_texts.setter
    def localized_texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs']]]]):
        pulumi.set(self, "localized_texts", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 language_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The localized content of this question choice.
        :param pulumi.Input[str] language_code: The ISO 639 language code for this question choice content.
        """
        AccessPackageAssignmentPolicyQuestionChoiceDisplayValueLocalizedTextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            language_code=language_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: pulumi.Input[str],
             language_code: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("language_code", language_code)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The localized content of this question choice.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        The ISO 639 language code for this question choice content.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionTextArgs:
    def __init__(__self__, *,
                 default_text: pulumi.Input[str],
                 localized_texts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs']]]] = None):
        """
        :param pulumi.Input[str] default_text: The default text of this question choice.
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs']]] localized_texts: One or more blocks describing localized text of this question choice, as documented below.
        """
        AccessPackageAssignmentPolicyQuestionTextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_text=default_text,
            localized_texts=localized_texts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_text: pulumi.Input[str],
             localized_texts: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("default_text", default_text)
        if localized_texts is not None:
            _setter("localized_texts", localized_texts)

    @property
    @pulumi.getter(name="defaultText")
    def default_text(self) -> pulumi.Input[str]:
        """
        The default text of this question choice.
        """
        return pulumi.get(self, "default_text")

    @default_text.setter
    def default_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_text", value)

    @property
    @pulumi.getter(name="localizedTexts")
    def localized_texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs']]]]:
        """
        One or more blocks describing localized text of this question choice, as documented below.
        """
        return pulumi.get(self, "localized_texts")

    @localized_texts.setter
    def localized_texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs']]]]):
        pulumi.set(self, "localized_texts", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 language_code: pulumi.Input[str]):
        """
        :param pulumi.Input[str] content: The localized content of this question choice.
        :param pulumi.Input[str] language_code: The ISO 639 language code for this question choice content.
        """
        AccessPackageAssignmentPolicyQuestionTextLocalizedTextArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            language_code=language_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: pulumi.Input[str],
             language_code: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        _setter("language_code", language_code)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        The localized content of this question choice.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[str]:
        """
        The ISO 639 language code for this question choice content.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "language_code", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyRequestorSettingsArgs:
    def __init__(__self__, *,
                 requestors: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs']]]] = None,
                 requests_accepted: Optional[pulumi.Input[bool]] = None,
                 scope_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs']]] requestors: A block specifying the users who are allowed to request on this policy, as documented below.
        :param pulumi.Input[bool] requests_accepted: Whether to accept requests using this policy. When `false`, no new requests can be made using this policy.
        :param pulumi.Input[str] scope_type: Specifies the scopes of the requestors. Valid values are `AllConfiguredConnectedOrganizationSubjects`, `AllExistingConnectedOrganizationSubjects`, `AllExistingDirectoryMemberUsers`, `AllExistingDirectorySubjects`, `AllExternalSubjects`, `NoSubjects`, `SpecificConnectedOrganizationSubjects`, or `SpecificDirectorySubjects`.
        """
        AccessPackageAssignmentPolicyRequestorSettingsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requestors=requestors,
            requests_accepted=requests_accepted,
            scope_type=scope_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requestors: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs']]]] = None,
             requests_accepted: Optional[pulumi.Input[bool]] = None,
             scope_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if requestors is not None:
            _setter("requestors", requestors)
        if requests_accepted is not None:
            _setter("requests_accepted", requests_accepted)
        if scope_type is not None:
            _setter("scope_type", scope_type)

    @property
    @pulumi.getter
    def requestors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs']]]]:
        """
        A block specifying the users who are allowed to request on this policy, as documented below.
        """
        return pulumi.get(self, "requestors")

    @requestors.setter
    def requestors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs']]]]):
        pulumi.set(self, "requestors", value)

    @property
    @pulumi.getter(name="requestsAccepted")
    def requests_accepted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to accept requests using this policy. When `false`, no new requests can be made using this policy.
        """
        return pulumi.get(self, "requests_accepted")

    @requests_accepted.setter
    def requests_accepted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "requests_accepted", value)

    @property
    @pulumi.getter(name="scopeType")
    def scope_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the scopes of the requestors. Valid values are `AllConfiguredConnectedOrganizationSubjects`, `AllExistingConnectedOrganizationSubjects`, `AllExistingDirectoryMemberUsers`, `AllExistingDirectorySubjects`, `AllExternalSubjects`, `NoSubjects`, `SpecificConnectedOrganizationSubjects`, or `SpecificDirectorySubjects`.
        """
        return pulumi.get(self, "scope_type")

    @scope_type.setter
    def scope_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope_type", value)


@pulumi.input_type
class AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs:
    def __init__(__self__, *,
                 subject_type: pulumi.Input[str],
                 backup: Optional[pulumi.Input[bool]] = None,
                 object_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject_type: Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        :param pulumi.Input[bool] backup: For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        :param pulumi.Input[str] object_id: The ID of the subject.
        """
        AccessPackageAssignmentPolicyRequestorSettingsRequestorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject_type=subject_type,
            backup=backup,
            object_id=object_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject_type: pulumi.Input[str],
             backup: Optional[pulumi.Input[bool]] = None,
             object_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subject_type", subject_type)
        if backup is not None:
            _setter("backup", backup)
        if object_id is not None:
            _setter("object_id", object_id)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Specifies the type of users. Valid values are `singleUser`, `groupMembers`, `connectedOrganizationMembers`, `requestorManager`, `internalSponsors`, or `externalSponsors`.
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)

    @property
    @pulumi.getter
    def backup(self) -> Optional[pulumi.Input[bool]]:
        """
        For a user in an approval stage, this property indicates whether the user is a backup fallback approver.
        """
        return pulumi.get(self, "backup")

    @backup.setter
    def backup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backup", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the subject.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)


@pulumi.input_type
class ApplicationApiArgs:
    def __init__(__self__, *,
                 known_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 mapped_claims_enabled: Optional[pulumi.Input[bool]] = None,
                 oauth2_permission_scopes: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationApiOauth2PermissionScopeArgs']]]] = None,
                 requested_access_token_version: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] known_client_applications: A set of application IDs (client IDs), used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app.
        :param pulumi.Input[bool] mapped_claims_enabled: Allows an application to use claims mapping without specifying a custom signing key. Defaults to `false`.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationApiOauth2PermissionScopeArgs']]] oauth2_permission_scopes: One or more `oauth2_permission_scope` blocks as documented below, to describe delegated permissions exposed by the web API represented by this application.
        :param pulumi.Input[int] requested_access_token_version: The access token version expected by this resource. Must be one of `1` or `2`, and must be `2` when `sign_in_audience` is either `AzureADandPersonalMicrosoftAccount` or `PersonalMicrosoftAccount` Defaults to `1`.
        """
        ApplicationApiArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            known_client_applications=known_client_applications,
            mapped_claims_enabled=mapped_claims_enabled,
            oauth2_permission_scopes=oauth2_permission_scopes,
            requested_access_token_version=requested_access_token_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             known_client_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             mapped_claims_enabled: Optional[pulumi.Input[bool]] = None,
             oauth2_permission_scopes: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationApiOauth2PermissionScopeArgs']]]] = None,
             requested_access_token_version: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if known_client_applications is not None:
            _setter("known_client_applications", known_client_applications)
        if mapped_claims_enabled is not None:
            _setter("mapped_claims_enabled", mapped_claims_enabled)
        if oauth2_permission_scopes is not None:
            _setter("oauth2_permission_scopes", oauth2_permission_scopes)
        if requested_access_token_version is not None:
            _setter("requested_access_token_version", requested_access_token_version)

    @property
    @pulumi.getter(name="knownClientApplications")
    def known_client_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of application IDs (client IDs), used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app.
        """
        return pulumi.get(self, "known_client_applications")

    @known_client_applications.setter
    def known_client_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "known_client_applications", value)

    @property
    @pulumi.getter(name="mappedClaimsEnabled")
    def mapped_claims_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows an application to use claims mapping without specifying a custom signing key. Defaults to `false`.
        """
        return pulumi.get(self, "mapped_claims_enabled")

    @mapped_claims_enabled.setter
    def mapped_claims_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mapped_claims_enabled", value)

    @property
    @pulumi.getter(name="oauth2PermissionScopes")
    def oauth2_permission_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationApiOauth2PermissionScopeArgs']]]]:
        """
        One or more `oauth2_permission_scope` blocks as documented below, to describe delegated permissions exposed by the web API represented by this application.
        """
        return pulumi.get(self, "oauth2_permission_scopes")

    @oauth2_permission_scopes.setter
    def oauth2_permission_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationApiOauth2PermissionScopeArgs']]]]):
        pulumi.set(self, "oauth2_permission_scopes", value)

    @property
    @pulumi.getter(name="requestedAccessTokenVersion")
    def requested_access_token_version(self) -> Optional[pulumi.Input[int]]:
        """
        The access token version expected by this resource. Must be one of `1` or `2`, and must be `2` when `sign_in_audience` is either `AzureADandPersonalMicrosoftAccount` or `PersonalMicrosoftAccount` Defaults to `1`.
        """
        return pulumi.get(self, "requested_access_token_version")

    @requested_access_token_version.setter
    def requested_access_token_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "requested_access_token_version", value)


@pulumi.input_type
class ApplicationApiOauth2PermissionScopeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 admin_consent_description: Optional[pulumi.Input[str]] = None,
                 admin_consent_display_name: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_consent_description: Optional[pulumi.Input[str]] = None,
                 user_consent_display_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_consent_description: Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
        :param pulumi.Input[str] admin_consent_display_name: Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
        :param pulumi.Input[bool] enabled: Determines if the permission scope is enabled. Defaults to `true`.
        :param pulumi.Input[str] type: Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Defaults to `User`. Possible values are `User` or `Admin`.
        :param pulumi.Input[str] user_consent_description: Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
        :param pulumi.Input[str] user_consent_display_name: Display name for the delegated permission that appears in the end user consent experience.
        """
        ApplicationApiOauth2PermissionScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            admin_consent_description=admin_consent_description,
            admin_consent_display_name=admin_consent_display_name,
            enabled=enabled,
            type=type,
            user_consent_description=user_consent_description,
            user_consent_display_name=user_consent_display_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             admin_consent_description: Optional[pulumi.Input[str]] = None,
             admin_consent_display_name: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             user_consent_description: Optional[pulumi.Input[str]] = None,
             user_consent_display_name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if admin_consent_description is not None:
            _setter("admin_consent_description", admin_consent_description)
        if admin_consent_display_name is not None:
            _setter("admin_consent_display_name", admin_consent_display_name)
        if enabled is not None:
            _setter("enabled", enabled)
        if type is not None:
            _setter("type", type)
        if user_consent_description is not None:
            _setter("user_consent_description", user_consent_description)
        if user_consent_display_name is not None:
            _setter("user_consent_display_name", user_consent_display_name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="adminConsentDescription")
    def admin_consent_description(self) -> Optional[pulumi.Input[str]]:
        """
        Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
        """
        return pulumi.get(self, "admin_consent_description")

    @admin_consent_description.setter
    def admin_consent_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_consent_description", value)

    @property
    @pulumi.getter(name="adminConsentDisplayName")
    def admin_consent_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
        """
        return pulumi.get(self, "admin_consent_display_name")

    @admin_consent_display_name.setter
    def admin_consent_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_consent_display_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the permission scope is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Defaults to `User`. Possible values are `User` or `Admin`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userConsentDescription")
    def user_consent_description(self) -> Optional[pulumi.Input[str]]:
        """
        Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
        """
        return pulumi.get(self, "user_consent_description")

    @user_consent_description.setter
    def user_consent_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_consent_description", value)

    @property
    @pulumi.getter(name="userConsentDisplayName")
    def user_consent_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name for the delegated permission that appears in the end user consent experience.
        """
        return pulumi.get(self, "user_consent_display_name")

    @user_consent_display_name.setter
    def user_consent_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_consent_display_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ApplicationAppRoleArgs:
    def __init__(__self__, *,
                 allowed_member_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 description: pulumi.Input[str],
                 display_name: pulumi.Input[str],
                 id: pulumi.Input[str],
                 enabled: Optional[pulumi.Input[bool]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_member_types: Specifies whether this app role definition can be assigned to users and groups by setting to `User`, or to other applications (that are accessing this application in a standalone scenario) by setting to `Application`, or to both.
        :param pulumi.Input[str] description: Description of the app role that appears when the role is being assigned and, if the role functions as an application permissions, during the consent experiences.
        :param pulumi.Input[str] display_name: Display name for the app role that appears during app role assignment and in consent experiences.
        :param pulumi.Input[bool] enabled: Determines if the app role is enabled. Defaults to `true`.
        """
        ApplicationAppRoleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_member_types=allowed_member_types,
            description=description,
            display_name=display_name,
            id=id,
            enabled=enabled,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_member_types: pulumi.Input[Sequence[pulumi.Input[str]]],
             description: pulumi.Input[str],
             display_name: pulumi.Input[str],
             id: pulumi.Input[str],
             enabled: Optional[pulumi.Input[bool]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allowed_member_types", allowed_member_types)
        _setter("description", description)
        _setter("display_name", display_name)
        _setter("id", id)
        if enabled is not None:
            _setter("enabled", enabled)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="allowedMemberTypes")
    def allowed_member_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies whether this app role definition can be assigned to users and groups by setting to `User`, or to other applications (that are accessing this application in a standalone scenario) by setting to `Application`, or to both.
        """
        return pulumi.get(self, "allowed_member_types")

    @allowed_member_types.setter
    def allowed_member_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_member_types", value)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Description of the app role that appears when the role is being assigned and, if the role functions as an application permissions, during the consent experiences.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[str]:
        """
        Display name for the app role that appears during app role assignment and in consent experiences.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines if the app role is enabled. Defaults to `true`.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ApplicationFeatureTagArgs:
    def __init__(__self__, *,
                 custom_single_sign_on: Optional[pulumi.Input[bool]] = None,
                 enterprise: Optional[pulumi.Input[bool]] = None,
                 gallery: Optional[pulumi.Input[bool]] = None,
                 hide: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] custom_single_sign_on: Whether this application represents a custom SAML application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryCustomSingleSignOnApplication` tag. Defaults to `false`.
        :param pulumi.Input[bool] enterprise: Whether this application represents an Enterprise Application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryIntegratedApp` tag. Defaults to `false`.
        :param pulumi.Input[bool] gallery: Whether this application represents a gallery application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryGalleryApplicationNonPrimaryV1` tag. Defaults to `false`.
        :param pulumi.Input[bool] hide: Whether this app is invisible to users in My Apps and Office 365 Launcher. Enabling this will assign the `HideApp` tag. Defaults to `false`.
        """
        ApplicationFeatureTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_single_sign_on=custom_single_sign_on,
            enterprise=enterprise,
            gallery=gallery,
            hide=hide,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_single_sign_on: Optional[pulumi.Input[bool]] = None,
             enterprise: Optional[pulumi.Input[bool]] = None,
             gallery: Optional[pulumi.Input[bool]] = None,
             hide: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_single_sign_on is not None:
            _setter("custom_single_sign_on", custom_single_sign_on)
        if enterprise is not None:
            _setter("enterprise", enterprise)
        if gallery is not None:
            _setter("gallery", gallery)
        if hide is not None:
            _setter("hide", hide)

    @property
    @pulumi.getter(name="customSingleSignOn")
    def custom_single_sign_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this application represents a custom SAML application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryCustomSingleSignOnApplication` tag. Defaults to `false`.
        """
        return pulumi.get(self, "custom_single_sign_on")

    @custom_single_sign_on.setter
    def custom_single_sign_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_single_sign_on", value)

    @property
    @pulumi.getter
    def enterprise(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this application represents an Enterprise Application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryIntegratedApp` tag. Defaults to `false`.
        """
        return pulumi.get(self, "enterprise")

    @enterprise.setter
    def enterprise(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enterprise", value)

    @property
    @pulumi.getter
    def gallery(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this application represents a gallery application for linked service principals. Enabling this will assign the `WindowsAzureActiveDirectoryGalleryApplicationNonPrimaryV1` tag. Defaults to `false`.
        """
        return pulumi.get(self, "gallery")

    @gallery.setter
    def gallery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gallery", value)

    @property
    @pulumi.getter
    def hide(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this app is invisible to users in My Apps and Office 365 Launcher. Enabling this will assign the `HideApp` tag. Defaults to `false`.
        """
        return pulumi.get(self, "hide")

    @hide.setter
    def hide(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide", value)


@pulumi.input_type
class ApplicationOptionalClaimsArgs:
    def __init__(__self__, *,
                 access_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsAccessTokenArgs']]]] = None,
                 id_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsIdTokenArgs']]]] = None,
                 saml2_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsSaml2TokenArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsAccessTokenArgs']]] access_tokens: One or more `access_token` blocks as documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsIdTokenArgs']]] id_tokens: One or more `id_token` blocks as documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsSaml2TokenArgs']]] saml2_tokens: One or more `saml2_token` blocks as documented below.
        """
        ApplicationOptionalClaimsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_tokens=access_tokens,
            id_tokens=id_tokens,
            saml2_tokens=saml2_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsAccessTokenArgs']]]] = None,
             id_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsIdTokenArgs']]]] = None,
             saml2_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsSaml2TokenArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_tokens is not None:
            _setter("access_tokens", access_tokens)
        if id_tokens is not None:
            _setter("id_tokens", id_tokens)
        if saml2_tokens is not None:
            _setter("saml2_tokens", saml2_tokens)

    @property
    @pulumi.getter(name="accessTokens")
    def access_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsAccessTokenArgs']]]]:
        """
        One or more `access_token` blocks as documented below.
        """
        return pulumi.get(self, "access_tokens")

    @access_tokens.setter
    def access_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsAccessTokenArgs']]]]):
        pulumi.set(self, "access_tokens", value)

    @property
    @pulumi.getter(name="idTokens")
    def id_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsIdTokenArgs']]]]:
        """
        One or more `id_token` blocks as documented below.
        """
        return pulumi.get(self, "id_tokens")

    @id_tokens.setter
    def id_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsIdTokenArgs']]]]):
        pulumi.set(self, "id_tokens", value)

    @property
    @pulumi.getter(name="saml2Tokens")
    def saml2_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsSaml2TokenArgs']]]]:
        """
        One or more `saml2_token` blocks as documented below.
        """
        return pulumi.get(self, "saml2_tokens")

    @saml2_tokens.setter
    def saml2_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationOptionalClaimsSaml2TokenArgs']]]]):
        pulumi.set(self, "saml2_tokens", value)


@pulumi.input_type
class ApplicationOptionalClaimsAccessTokenArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 essential: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the optional claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_properties: List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        :param pulumi.Input[bool] essential: Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        :param pulumi.Input[str] source: The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        ApplicationOptionalClaimsAccessTokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            additional_properties=additional_properties,
            essential=essential,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             essential: Optional[pulumi.Input[bool]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if additional_properties is not None:
            _setter("additional_properties", additional_properties)
        if essential is not None:
            _setter("essential", essential)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the optional claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def essential(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        """
        return pulumi.get(self, "essential")

    @essential.setter
    def essential(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "essential", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class ApplicationOptionalClaimsIdTokenArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 essential: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the optional claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_properties: List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        :param pulumi.Input[bool] essential: Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        :param pulumi.Input[str] source: The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        ApplicationOptionalClaimsIdTokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            additional_properties=additional_properties,
            essential=essential,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             essential: Optional[pulumi.Input[bool]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if additional_properties is not None:
            _setter("additional_properties", additional_properties)
        if essential is not None:
            _setter("essential", essential)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the optional claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def essential(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        """
        return pulumi.get(self, "essential")

    @essential.setter
    def essential(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "essential", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class ApplicationOptionalClaimsSaml2TokenArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 essential: Optional[pulumi.Input[bool]] = None,
                 source: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the optional claim.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_properties: List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        :param pulumi.Input[bool] essential: Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        :param pulumi.Input[str] source: The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        ApplicationOptionalClaimsSaml2TokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            additional_properties=additional_properties,
            essential=essential,
            source=source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             additional_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             essential: Optional[pulumi.Input[bool]] = None,
             source: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if additional_properties is not None:
            _setter("additional_properties", additional_properties)
        if essential is not None:
            _setter("essential", essential)
        if source is not None:
            _setter("source", source)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the optional claim.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "additional_properties", value)

    @property
    @pulumi.getter
    def essential(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
        """
        return pulumi.get(self, "essential")

    @essential.setter
    def essential(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "essential", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class ApplicationPublicClientArgs:
    def __init__(__self__, *,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `https` or `ms-appx-web` URL.
        """
        ApplicationPublicClientArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_uris=redirect_uris,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if redirect_uris is not None:
            _setter("redirect_uris", redirect_uris)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `https` or `ms-appx-web` URL.
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)


@pulumi.input_type
class ApplicationRequiredResourceAccessArgs:
    def __init__(__self__, *,
                 resource_accesses: pulumi.Input[Sequence[pulumi.Input['ApplicationRequiredResourceAccessResourceAccessArgs']]],
                 resource_app_id: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationRequiredResourceAccessResourceAccessArgs']]] resource_accesses: A collection of `resource_access` blocks as documented below, describing OAuth2.0 permission scopes and app roles that the application requires from the specified resource.
        :param pulumi.Input[str] resource_app_id: The unique identifier for the resource that the application requires access to. This should be the Application ID of the target application.
               
               > **Note:** Documentation on `resource_app_id` values for Microsoft APIs can be difficult to find, but you can use the [Azure CLI](https://docs.microsoft.com/en-us/cli/azure/ad/sp?view=azure-cli-latest#az_ad_sp_list) to find them. (e.g. `az ad sp list --display-name "Microsoft Graph" --query '[].{appDisplayName:appDisplayName, appId:appId}'`)
        """
        ApplicationRequiredResourceAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            resource_accesses=resource_accesses,
            resource_app_id=resource_app_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             resource_accesses: pulumi.Input[Sequence[pulumi.Input['ApplicationRequiredResourceAccessResourceAccessArgs']]],
             resource_app_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("resource_accesses", resource_accesses)
        _setter("resource_app_id", resource_app_id)

    @property
    @pulumi.getter(name="resourceAccesses")
    def resource_accesses(self) -> pulumi.Input[Sequence[pulumi.Input['ApplicationRequiredResourceAccessResourceAccessArgs']]]:
        """
        A collection of `resource_access` blocks as documented below, describing OAuth2.0 permission scopes and app roles that the application requires from the specified resource.
        """
        return pulumi.get(self, "resource_accesses")

    @resource_accesses.setter
    def resource_accesses(self, value: pulumi.Input[Sequence[pulumi.Input['ApplicationRequiredResourceAccessResourceAccessArgs']]]):
        pulumi.set(self, "resource_accesses", value)

    @property
    @pulumi.getter(name="resourceAppId")
    def resource_app_id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the resource that the application requires access to. This should be the Application ID of the target application.

        > **Note:** Documentation on `resource_app_id` values for Microsoft APIs can be difficult to find, but you can use the [Azure CLI](https://docs.microsoft.com/en-us/cli/azure/ad/sp?view=azure-cli-latest#az_ad_sp_list) to find them. (e.g. `az ad sp list --display-name "Microsoft Graph" --query '[].{appDisplayName:appDisplayName, appId:appId}'`)
        """
        return pulumi.get(self, "resource_app_id")

    @resource_app_id.setter
    def resource_app_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_app_id", value)


@pulumi.input_type
class ApplicationRequiredResourceAccessResourceAccessArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The unique identifier for an app role or OAuth2 permission scope published by the resource application.
        :param pulumi.Input[str] type: Specifies whether the `id` property references an app role or an OAuth2 permission scope. Possible values are `Role` or `Scope`.
        """
        ApplicationRequiredResourceAccessResourceAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier for an app role or OAuth2 permission scope published by the resource application.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies whether the `id` property references an app role or an OAuth2 permission scope. Possible values are `Role` or `Scope`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ApplicationSinglePageApplicationArgs:
    def __init__(__self__, *,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `https` URL.
        """
        ApplicationSinglePageApplicationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_uris=redirect_uris,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if redirect_uris is not None:
            _setter("redirect_uris", redirect_uris)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `https` URL.
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)


@pulumi.input_type
class ApplicationWebArgs:
    def __init__(__self__, *,
                 homepage_url: Optional[pulumi.Input[str]] = None,
                 implicit_grant: Optional[pulumi.Input['ApplicationWebImplicitGrantArgs']] = None,
                 logout_url: Optional[pulumi.Input[str]] = None,
                 redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] homepage_url: Home page or landing page of the application.
        :param pulumi.Input['ApplicationWebImplicitGrantArgs'] implicit_grant: An `implicit_grant` block as documented above.
        :param pulumi.Input[str] logout_url: The URL that will be used by Microsoft's authorization service to sign out a user using front-channel, back-channel or SAML logout protocols.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] redirect_uris: A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `http` URL or a URN.
        """
        ApplicationWebArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            homepage_url=homepage_url,
            implicit_grant=implicit_grant,
            logout_url=logout_url,
            redirect_uris=redirect_uris,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             homepage_url: Optional[pulumi.Input[str]] = None,
             implicit_grant: Optional[pulumi.Input['ApplicationWebImplicitGrantArgs']] = None,
             logout_url: Optional[pulumi.Input[str]] = None,
             redirect_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if homepage_url is not None:
            _setter("homepage_url", homepage_url)
        if implicit_grant is not None:
            _setter("implicit_grant", implicit_grant)
        if logout_url is not None:
            _setter("logout_url", logout_url)
        if redirect_uris is not None:
            _setter("redirect_uris", redirect_uris)

    @property
    @pulumi.getter(name="homepageUrl")
    def homepage_url(self) -> Optional[pulumi.Input[str]]:
        """
        Home page or landing page of the application.
        """
        return pulumi.get(self, "homepage_url")

    @homepage_url.setter
    def homepage_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "homepage_url", value)

    @property
    @pulumi.getter(name="implicitGrant")
    def implicit_grant(self) -> Optional[pulumi.Input['ApplicationWebImplicitGrantArgs']]:
        """
        An `implicit_grant` block as documented above.
        """
        return pulumi.get(self, "implicit_grant")

    @implicit_grant.setter
    def implicit_grant(self, value: Optional[pulumi.Input['ApplicationWebImplicitGrantArgs']]):
        pulumi.set(self, "implicit_grant", value)

    @property
    @pulumi.getter(name="logoutUrl")
    def logout_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL that will be used by Microsoft's authorization service to sign out a user using front-channel, back-channel or SAML logout protocols.
        """
        return pulumi.get(self, "logout_url")

    @logout_url.setter
    def logout_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logout_url", value)

    @property
    @pulumi.getter(name="redirectUris")
    def redirect_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent. Must be a valid `http` URL or a URN.
        """
        return pulumi.get(self, "redirect_uris")

    @redirect_uris.setter
    def redirect_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "redirect_uris", value)


@pulumi.input_type
class ApplicationWebImplicitGrantArgs:
    def __init__(__self__, *,
                 access_token_issuance_enabled: Optional[pulumi.Input[bool]] = None,
                 id_token_issuance_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] access_token_issuance_enabled: Whether this web application can request an access token using OAuth 2.0 implicit flow.
        :param pulumi.Input[bool] id_token_issuance_enabled: Whether this web application can request an ID token using OAuth 2.0 implicit flow.
        """
        ApplicationWebImplicitGrantArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token_issuance_enabled=access_token_issuance_enabled,
            id_token_issuance_enabled=id_token_issuance_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token_issuance_enabled: Optional[pulumi.Input[bool]] = None,
             id_token_issuance_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_token_issuance_enabled is not None:
            _setter("access_token_issuance_enabled", access_token_issuance_enabled)
        if id_token_issuance_enabled is not None:
            _setter("id_token_issuance_enabled", id_token_issuance_enabled)

    @property
    @pulumi.getter(name="accessTokenIssuanceEnabled")
    def access_token_issuance_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this web application can request an access token using OAuth 2.0 implicit flow.
        """
        return pulumi.get(self, "access_token_issuance_enabled")

    @access_token_issuance_enabled.setter
    def access_token_issuance_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token_issuance_enabled", value)

    @property
    @pulumi.getter(name="idTokenIssuanceEnabled")
    def id_token_issuance_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this web application can request an ID token using OAuth 2.0 implicit flow.
        """
        return pulumi.get(self, "id_token_issuance_enabled")

    @id_token_issuance_enabled.setter
    def id_token_issuance_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "id_token_issuance_enabled", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsArgs:
    def __init__(__self__, *,
                 applications: pulumi.Input['ConditionalAccessPolicyConditionsApplicationsArgs'],
                 client_app_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 users: pulumi.Input['ConditionalAccessPolicyConditionsUsersArgs'],
                 client_applications: Optional[pulumi.Input['ConditionalAccessPolicyConditionsClientApplicationsArgs']] = None,
                 devices: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesArgs']] = None,
                 locations: Optional[pulumi.Input['ConditionalAccessPolicyConditionsLocationsArgs']] = None,
                 platforms: Optional[pulumi.Input['ConditionalAccessPolicyConditionsPlatformsArgs']] = None,
                 service_principal_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sign_in_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ConditionalAccessPolicyConditionsApplicationsArgs'] applications: An `applications` block as documented below, which specifies applications and user actions included in and excluded from the policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] client_app_types: A list of client application types included in the policy. Possible values are: `all`, `browser`, `mobileAppsAndDesktopClients`, `exchangeActiveSync`, `easSupported` and `other`.
        :param pulumi.Input['ConditionalAccessPolicyConditionsUsersArgs'] users: A `users` block as documented below, which specifies users, groups, and roles included in and excluded from the policy.
        :param pulumi.Input['ConditionalAccessPolicyConditionsClientApplicationsArgs'] client_applications: An `client_applications` block as documented below, which specifies service principals included in and excluded from the policy.
        :param pulumi.Input['ConditionalAccessPolicyConditionsDevicesArgs'] devices: A `devices` block as documented below, which describes devices to be included in and excluded from the policy. A `devices` block can be added to an existing policy, but removing the `devices` block forces a new resource to be created.
        :param pulumi.Input['ConditionalAccessPolicyConditionsLocationsArgs'] locations: A `locations` block as documented below, which specifies locations included in and excluded from the policy.
        :param pulumi.Input['ConditionalAccessPolicyConditionsPlatformsArgs'] platforms: A `platforms` block as documented below, which specifies platforms included in and excluded from the policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_principal_risk_levels: A list of service principal sign-in risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `none`, `unknownFutureValue`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sign_in_risk_levels: A list of user sign-in risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `hidden`, `none`, `unknownFutureValue`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_risk_levels: A list of user risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `hidden`, `none`, `unknownFutureValue`.
        """
        ConditionalAccessPolicyConditionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            applications=applications,
            client_app_types=client_app_types,
            users=users,
            client_applications=client_applications,
            devices=devices,
            locations=locations,
            platforms=platforms,
            service_principal_risk_levels=service_principal_risk_levels,
            sign_in_risk_levels=sign_in_risk_levels,
            user_risk_levels=user_risk_levels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             applications: pulumi.Input['ConditionalAccessPolicyConditionsApplicationsArgs'],
             client_app_types: pulumi.Input[Sequence[pulumi.Input[str]]],
             users: pulumi.Input['ConditionalAccessPolicyConditionsUsersArgs'],
             client_applications: Optional[pulumi.Input['ConditionalAccessPolicyConditionsClientApplicationsArgs']] = None,
             devices: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesArgs']] = None,
             locations: Optional[pulumi.Input['ConditionalAccessPolicyConditionsLocationsArgs']] = None,
             platforms: Optional[pulumi.Input['ConditionalAccessPolicyConditionsPlatformsArgs']] = None,
             service_principal_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             sign_in_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             user_risk_levels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("applications", applications)
        _setter("client_app_types", client_app_types)
        _setter("users", users)
        if client_applications is not None:
            _setter("client_applications", client_applications)
        if devices is not None:
            _setter("devices", devices)
        if locations is not None:
            _setter("locations", locations)
        if platforms is not None:
            _setter("platforms", platforms)
        if service_principal_risk_levels is not None:
            _setter("service_principal_risk_levels", service_principal_risk_levels)
        if sign_in_risk_levels is not None:
            _setter("sign_in_risk_levels", sign_in_risk_levels)
        if user_risk_levels is not None:
            _setter("user_risk_levels", user_risk_levels)

    @property
    @pulumi.getter
    def applications(self) -> pulumi.Input['ConditionalAccessPolicyConditionsApplicationsArgs']:
        """
        An `applications` block as documented below, which specifies applications and user actions included in and excluded from the policy.
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: pulumi.Input['ConditionalAccessPolicyConditionsApplicationsArgs']):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter(name="clientAppTypes")
    def client_app_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of client application types included in the policy. Possible values are: `all`, `browser`, `mobileAppsAndDesktopClients`, `exchangeActiveSync`, `easSupported` and `other`.
        """
        return pulumi.get(self, "client_app_types")

    @client_app_types.setter
    def client_app_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "client_app_types", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input['ConditionalAccessPolicyConditionsUsersArgs']:
        """
        A `users` block as documented below, which specifies users, groups, and roles included in and excluded from the policy.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input['ConditionalAccessPolicyConditionsUsersArgs']):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter(name="clientApplications")
    def client_applications(self) -> Optional[pulumi.Input['ConditionalAccessPolicyConditionsClientApplicationsArgs']]:
        """
        An `client_applications` block as documented below, which specifies service principals included in and excluded from the policy.
        """
        return pulumi.get(self, "client_applications")

    @client_applications.setter
    def client_applications(self, value: Optional[pulumi.Input['ConditionalAccessPolicyConditionsClientApplicationsArgs']]):
        pulumi.set(self, "client_applications", value)

    @property
    @pulumi.getter
    def devices(self) -> Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesArgs']]:
        """
        A `devices` block as documented below, which describes devices to be included in and excluded from the policy. A `devices` block can be added to an existing policy, but removing the `devices` block forces a new resource to be created.
        """
        return pulumi.get(self, "devices")

    @devices.setter
    def devices(self, value: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesArgs']]):
        pulumi.set(self, "devices", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input['ConditionalAccessPolicyConditionsLocationsArgs']]:
        """
        A `locations` block as documented below, which specifies locations included in and excluded from the policy.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input['ConditionalAccessPolicyConditionsLocationsArgs']]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter
    def platforms(self) -> Optional[pulumi.Input['ConditionalAccessPolicyConditionsPlatformsArgs']]:
        """
        A `platforms` block as documented below, which specifies platforms included in and excluded from the policy.
        """
        return pulumi.get(self, "platforms")

    @platforms.setter
    def platforms(self, value: Optional[pulumi.Input['ConditionalAccessPolicyConditionsPlatformsArgs']]):
        pulumi.set(self, "platforms", value)

    @property
    @pulumi.getter(name="servicePrincipalRiskLevels")
    def service_principal_risk_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of service principal sign-in risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `none`, `unknownFutureValue`.
        """
        return pulumi.get(self, "service_principal_risk_levels")

    @service_principal_risk_levels.setter
    def service_principal_risk_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_principal_risk_levels", value)

    @property
    @pulumi.getter(name="signInRiskLevels")
    def sign_in_risk_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of user sign-in risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `hidden`, `none`, `unknownFutureValue`.
        """
        return pulumi.get(self, "sign_in_risk_levels")

    @sign_in_risk_levels.setter
    def sign_in_risk_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sign_in_risk_levels", value)

    @property
    @pulumi.getter(name="userRiskLevels")
    def user_risk_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of user risk levels included in the policy. Possible values are: `low`, `medium`, `high`, `hidden`, `none`, `unknownFutureValue`.
        """
        return pulumi.get(self, "user_risk_levels")

    @user_risk_levels.setter
    def user_risk_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_risk_levels", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsApplicationsArgs:
    def __init__(__self__, *,
                 excluded_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_user_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_applications: A list of application IDs explicitly excluded from the policy. Can also be set to `Office365`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_applications: A list of application IDs the policy applies to, unless explicitly excluded (in `excluded_applications`). Can also be set to `All`, `None` or `Office365`. Cannot be specified with `included_user_actions`. One of `included_applications` or `included_user_actions` must be specified.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_user_actions: A list of user actions to include. Supported values are `urn:user:registerdevice` and `urn:user:registersecurityinfo`. Cannot be specified with `included_applications`. One of `included_applications` or `included_user_actions` must be specified.
        """
        ConditionalAccessPolicyConditionsApplicationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_applications=excluded_applications,
            included_applications=included_applications,
            included_user_actions=included_user_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_applications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_user_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if excluded_applications is not None:
            _setter("excluded_applications", excluded_applications)
        if included_applications is not None:
            _setter("included_applications", included_applications)
        if included_user_actions is not None:
            _setter("included_user_actions", included_user_actions)

    @property
    @pulumi.getter(name="excludedApplications")
    def excluded_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of application IDs explicitly excluded from the policy. Can also be set to `Office365`.
        """
        return pulumi.get(self, "excluded_applications")

    @excluded_applications.setter
    def excluded_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_applications", value)

    @property
    @pulumi.getter(name="includedApplications")
    def included_applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of application IDs the policy applies to, unless explicitly excluded (in `excluded_applications`). Can also be set to `All`, `None` or `Office365`. Cannot be specified with `included_user_actions`. One of `included_applications` or `included_user_actions` must be specified.
        """
        return pulumi.get(self, "included_applications")

    @included_applications.setter
    def included_applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_applications", value)

    @property
    @pulumi.getter(name="includedUserActions")
    def included_user_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of user actions to include. Supported values are `urn:user:registerdevice` and `urn:user:registersecurityinfo`. Cannot be specified with `included_applications`. One of `included_applications` or `included_user_actions` must be specified.
        """
        return pulumi.get(self, "included_user_actions")

    @included_user_actions.setter
    def included_user_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_user_actions", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsClientApplicationsArgs:
    def __init__(__self__, *,
                 excluded_service_principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_service_principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_service_principals: A list of service principal IDs explicitly excluded in the policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_service_principals: A list of service principal IDs explicitly included in the policy. Can be set to `ServicePrincipalsInMyTenant` to include all service principals. This is mandatory value when at least one `excluded_service_principals` is set.
        """
        ConditionalAccessPolicyConditionsClientApplicationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_service_principals=excluded_service_principals,
            included_service_principals=included_service_principals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_service_principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_service_principals: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if excluded_service_principals is not None:
            _setter("excluded_service_principals", excluded_service_principals)
        if included_service_principals is not None:
            _setter("included_service_principals", included_service_principals)

    @property
    @pulumi.getter(name="excludedServicePrincipals")
    def excluded_service_principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of service principal IDs explicitly excluded in the policy.
        """
        return pulumi.get(self, "excluded_service_principals")

    @excluded_service_principals.setter
    def excluded_service_principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_service_principals", value)

    @property
    @pulumi.getter(name="includedServicePrincipals")
    def included_service_principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of service principal IDs explicitly included in the policy. Can be set to `ServicePrincipalsInMyTenant` to include all service principals. This is mandatory value when at least one `excluded_service_principals` is set.
        """
        return pulumi.get(self, "included_service_principals")

    @included_service_principals.setter
    def included_service_principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_service_principals", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsDevicesArgs:
    def __init__(__self__, *,
                 filter: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesFilterArgs']] = None):
        """
        :param pulumi.Input['ConditionalAccessPolicyConditionsDevicesFilterArgs'] filter: A `filter` block as described below. A `filter` block can be added to an existing policy, but removing the `filter` block forces a new resource to be created.
        """
        ConditionalAccessPolicyConditionsDevicesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter=filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesFilterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filter is not None:
            _setter("filter", filter)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesFilterArgs']]:
        """
        A `filter` block as described below. A `filter` block can be added to an existing policy, but removing the `filter` block forces a new resource to be created.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['ConditionalAccessPolicyConditionsDevicesFilterArgs']]):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsDevicesFilterArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 rule: pulumi.Input[str]):
        """
        :param pulumi.Input[str] mode: Whether to include in, or exclude from, matching devices from the policy. Supported values are `include` or `exclude`.
        :param pulumi.Input[str] rule: Condition filter to match devices. For more information, see [official documentation](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/concept-condition-filters-for-devices#supported-operators-and-device-properties-for-filters).
        """
        ConditionalAccessPolicyConditionsDevicesFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            rule=rule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: pulumi.Input[str],
             rule: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("mode", mode)
        _setter("rule", rule)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        """
        Whether to include in, or exclude from, matching devices from the policy. Supported values are `include` or `exclude`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        Condition filter to match devices. For more information, see [official documentation](https://docs.microsoft.com/en-us/azure/active-directory/conditional-access/concept-condition-filters-for-devices#supported-operators-and-device-properties-for-filters).
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsLocationsArgs:
    def __init__(__self__, *,
                 included_locations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 excluded_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_locations: A list of location IDs in scope of policy unless explicitly excluded. Can also be set to `All`, or `AllTrusted`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_locations: A list of location IDs excluded from scope of policy. Can also be set to `AllTrusted`.
        """
        ConditionalAccessPolicyConditionsLocationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            included_locations=included_locations,
            excluded_locations=excluded_locations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             included_locations: pulumi.Input[Sequence[pulumi.Input[str]]],
             excluded_locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("included_locations", included_locations)
        if excluded_locations is not None:
            _setter("excluded_locations", excluded_locations)

    @property
    @pulumi.getter(name="includedLocations")
    def included_locations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of location IDs in scope of policy unless explicitly excluded. Can also be set to `All`, or `AllTrusted`.
        """
        return pulumi.get(self, "included_locations")

    @included_locations.setter
    def included_locations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "included_locations", value)

    @property
    @pulumi.getter(name="excludedLocations")
    def excluded_locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of location IDs excluded from scope of policy. Can also be set to `AllTrusted`.
        """
        return pulumi.get(self, "excluded_locations")

    @excluded_locations.setter
    def excluded_locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_locations", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsPlatformsArgs:
    def __init__(__self__, *,
                 included_platforms: pulumi.Input[Sequence[pulumi.Input[str]]],
                 excluded_platforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_platforms: A list of platforms the policy applies to, unless explicitly excluded. Possible values are: `all`, `android`, `iOS`, `linux`, `macOS`, `windows`, `windowsPhone` or `unknownFutureValue`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_platforms: A list of platforms explicitly excluded from the policy. Possible values are: `all`, `android`, `iOS`, `linux`, `macOS`, `windows`, `windowsPhone` or `unknownFutureValue`.
        """
        ConditionalAccessPolicyConditionsPlatformsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            included_platforms=included_platforms,
            excluded_platforms=excluded_platforms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             included_platforms: pulumi.Input[Sequence[pulumi.Input[str]]],
             excluded_platforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("included_platforms", included_platforms)
        if excluded_platforms is not None:
            _setter("excluded_platforms", excluded_platforms)

    @property
    @pulumi.getter(name="includedPlatforms")
    def included_platforms(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of platforms the policy applies to, unless explicitly excluded. Possible values are: `all`, `android`, `iOS`, `linux`, `macOS`, `windows`, `windowsPhone` or `unknownFutureValue`.
        """
        return pulumi.get(self, "included_platforms")

    @included_platforms.setter
    def included_platforms(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "included_platforms", value)

    @property
    @pulumi.getter(name="excludedPlatforms")
    def excluded_platforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of platforms explicitly excluded from the policy. Possible values are: `all`, `android`, `iOS`, `linux`, `macOS`, `windows`, `windowsPhone` or `unknownFutureValue`.
        """
        return pulumi.get(self, "excluded_platforms")

    @excluded_platforms.setter
    def excluded_platforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_platforms", value)


@pulumi.input_type
class ConditionalAccessPolicyConditionsUsersArgs:
    def __init__(__self__, *,
                 excluded_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 excluded_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_groups: A list of group IDs excluded from scope of policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_roles: A list of role IDs excluded from scope of policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] excluded_users: A list of user IDs excluded from scope of policy and/or `GuestsOrExternalUsers`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_groups: A list of group IDs in scope of policy unless explicitly excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_roles: A list of role IDs in scope of policy unless explicitly excluded.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_users: A list of user IDs in scope of policy unless explicitly excluded, or `None` or `All` or `GuestsOrExternalUsers`.
               
               > At least one of `included_groups`, `included_roles` or `included_users` must be specified.
        """
        ConditionalAccessPolicyConditionsUsersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            excluded_groups=excluded_groups,
            excluded_roles=excluded_roles,
            excluded_users=excluded_users,
            included_groups=included_groups,
            included_roles=included_roles,
            included_users=included_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             excluded_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             excluded_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             excluded_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             included_users: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if excluded_groups is not None:
            _setter("excluded_groups", excluded_groups)
        if excluded_roles is not None:
            _setter("excluded_roles", excluded_roles)
        if excluded_users is not None:
            _setter("excluded_users", excluded_users)
        if included_groups is not None:
            _setter("included_groups", included_groups)
        if included_roles is not None:
            _setter("included_roles", included_roles)
        if included_users is not None:
            _setter("included_users", included_users)

    @property
    @pulumi.getter(name="excludedGroups")
    def excluded_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of group IDs excluded from scope of policy.
        """
        return pulumi.get(self, "excluded_groups")

    @excluded_groups.setter
    def excluded_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_groups", value)

    @property
    @pulumi.getter(name="excludedRoles")
    def excluded_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of role IDs excluded from scope of policy.
        """
        return pulumi.get(self, "excluded_roles")

    @excluded_roles.setter
    def excluded_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_roles", value)

    @property
    @pulumi.getter(name="excludedUsers")
    def excluded_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of user IDs excluded from scope of policy and/or `GuestsOrExternalUsers`.
        """
        return pulumi.get(self, "excluded_users")

    @excluded_users.setter
    def excluded_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excluded_users", value)

    @property
    @pulumi.getter(name="includedGroups")
    def included_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of group IDs in scope of policy unless explicitly excluded.
        """
        return pulumi.get(self, "included_groups")

    @included_groups.setter
    def included_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_groups", value)

    @property
    @pulumi.getter(name="includedRoles")
    def included_roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of role IDs in scope of policy unless explicitly excluded.
        """
        return pulumi.get(self, "included_roles")

    @included_roles.setter
    def included_roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_roles", value)

    @property
    @pulumi.getter(name="includedUsers")
    def included_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of user IDs in scope of policy unless explicitly excluded, or `None` or `All` or `GuestsOrExternalUsers`.

        > At least one of `included_groups`, `included_roles` or `included_users` must be specified.
        """
        return pulumi.get(self, "included_users")

    @included_users.setter
    def included_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_users", value)


@pulumi.input_type
class ConditionalAccessPolicyGrantControlsArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 built_in_controls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_authentication_factors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 terms_of_uses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] operator: Defines the relationship of the grant controls. Possible values are: `AND`, `OR`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] built_in_controls: List of built-in controls required by the policy. Possible values are: `block`, `mfa`, `approvedApplication`, `compliantApplication`, `compliantDevice`, `domainJoinedDevice`, `passwordChange` or `unknownFutureValue`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_authentication_factors: List of custom controls IDs required by the policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] terms_of_uses: List of terms of use IDs required by the policy.
               
               > At least one of `built_in_controls` or `terms_of_use` must be specified.
        """
        ConditionalAccessPolicyGrantControlsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            built_in_controls=built_in_controls,
            custom_authentication_factors=custom_authentication_factors,
            terms_of_uses=terms_of_uses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: pulumi.Input[str],
             built_in_controls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             custom_authentication_factors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             terms_of_uses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        if built_in_controls is not None:
            _setter("built_in_controls", built_in_controls)
        if custom_authentication_factors is not None:
            _setter("custom_authentication_factors", custom_authentication_factors)
        if terms_of_uses is not None:
            _setter("terms_of_uses", terms_of_uses)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Defines the relationship of the grant controls. Possible values are: `AND`, `OR`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="builtInControls")
    def built_in_controls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of built-in controls required by the policy. Possible values are: `block`, `mfa`, `approvedApplication`, `compliantApplication`, `compliantDevice`, `domainJoinedDevice`, `passwordChange` or `unknownFutureValue`.
        """
        return pulumi.get(self, "built_in_controls")

    @built_in_controls.setter
    def built_in_controls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "built_in_controls", value)

    @property
    @pulumi.getter(name="customAuthenticationFactors")
    def custom_authentication_factors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of custom controls IDs required by the policy.
        """
        return pulumi.get(self, "custom_authentication_factors")

    @custom_authentication_factors.setter
    def custom_authentication_factors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_authentication_factors", value)

    @property
    @pulumi.getter(name="termsOfUses")
    def terms_of_uses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of terms of use IDs required by the policy.

        > At least one of `built_in_controls` or `terms_of_use` must be specified.
        """
        return pulumi.get(self, "terms_of_uses")

    @terms_of_uses.setter
    def terms_of_uses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "terms_of_uses", value)


@pulumi.input_type
class ConditionalAccessPolicySessionControlsArgs:
    def __init__(__self__, *,
                 application_enforced_restrictions_enabled: Optional[pulumi.Input[bool]] = None,
                 cloud_app_security_policy: Optional[pulumi.Input[str]] = None,
                 disable_resilience_defaults: Optional[pulumi.Input[bool]] = None,
                 persistent_browser_mode: Optional[pulumi.Input[str]] = None,
                 sign_in_frequency: Optional[pulumi.Input[int]] = None,
                 sign_in_frequency_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] application_enforced_restrictions_enabled: Whether or not application enforced restrictions are enabled. Defaults to `false`.
               
               > Only Office 365, Exchange Online and Sharepoint Online support application enforced restrictions.
        :param pulumi.Input[str] cloud_app_security_policy: Enables cloud app security and specifies the cloud app security policy to use. Possible values are: `blockDownloads`, `mcasConfigured`, `monitorOnly` or `unknownFutureValue`.
        :param pulumi.Input[bool] disable_resilience_defaults: Disables [resilience defaults](https://learn.microsoft.com/en-us/azure/active-directory/conditional-access/resilience-defaults). Defaults to `false`.
        :param pulumi.Input[str] persistent_browser_mode: Session control to define whether to persist cookies or not. Possible values are: `always` or `never`.
        :param pulumi.Input[int] sign_in_frequency: Number of days or hours to enforce sign-in frequency. Required when `sign_in_frequency_period` is specified. Due to an API issue, removing this property forces a new resource to be created.
        :param pulumi.Input[str] sign_in_frequency_period: The time period to enforce sign-in frequency. Possible values are: `hours` or `days`. Required when `sign_in_frequency_period` is specified. Due to an API issue, removing this property forces a new resource to be created.
        """
        ConditionalAccessPolicySessionControlsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            application_enforced_restrictions_enabled=application_enforced_restrictions_enabled,
            cloud_app_security_policy=cloud_app_security_policy,
            disable_resilience_defaults=disable_resilience_defaults,
            persistent_browser_mode=persistent_browser_mode,
            sign_in_frequency=sign_in_frequency,
            sign_in_frequency_period=sign_in_frequency_period,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             application_enforced_restrictions_enabled: Optional[pulumi.Input[bool]] = None,
             cloud_app_security_policy: Optional[pulumi.Input[str]] = None,
             disable_resilience_defaults: Optional[pulumi.Input[bool]] = None,
             persistent_browser_mode: Optional[pulumi.Input[str]] = None,
             sign_in_frequency: Optional[pulumi.Input[int]] = None,
             sign_in_frequency_period: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if application_enforced_restrictions_enabled is not None:
            _setter("application_enforced_restrictions_enabled", application_enforced_restrictions_enabled)
        if cloud_app_security_policy is not None:
            _setter("cloud_app_security_policy", cloud_app_security_policy)
        if disable_resilience_defaults is not None:
            _setter("disable_resilience_defaults", disable_resilience_defaults)
        if persistent_browser_mode is not None:
            _setter("persistent_browser_mode", persistent_browser_mode)
        if sign_in_frequency is not None:
            _setter("sign_in_frequency", sign_in_frequency)
        if sign_in_frequency_period is not None:
            _setter("sign_in_frequency_period", sign_in_frequency_period)

    @property
    @pulumi.getter(name="applicationEnforcedRestrictionsEnabled")
    def application_enforced_restrictions_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not application enforced restrictions are enabled. Defaults to `false`.

        > Only Office 365, Exchange Online and Sharepoint Online support application enforced restrictions.
        """
        return pulumi.get(self, "application_enforced_restrictions_enabled")

    @application_enforced_restrictions_enabled.setter
    def application_enforced_restrictions_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "application_enforced_restrictions_enabled", value)

    @property
    @pulumi.getter(name="cloudAppSecurityPolicy")
    def cloud_app_security_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Enables cloud app security and specifies the cloud app security policy to use. Possible values are: `blockDownloads`, `mcasConfigured`, `monitorOnly` or `unknownFutureValue`.
        """
        return pulumi.get(self, "cloud_app_security_policy")

    @cloud_app_security_policy.setter
    def cloud_app_security_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_app_security_policy", value)

    @property
    @pulumi.getter(name="disableResilienceDefaults")
    def disable_resilience_defaults(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables [resilience defaults](https://learn.microsoft.com/en-us/azure/active-directory/conditional-access/resilience-defaults). Defaults to `false`.
        """
        return pulumi.get(self, "disable_resilience_defaults")

    @disable_resilience_defaults.setter
    def disable_resilience_defaults(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_resilience_defaults", value)

    @property
    @pulumi.getter(name="persistentBrowserMode")
    def persistent_browser_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Session control to define whether to persist cookies or not. Possible values are: `always` or `never`.
        """
        return pulumi.get(self, "persistent_browser_mode")

    @persistent_browser_mode.setter
    def persistent_browser_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_browser_mode", value)

    @property
    @pulumi.getter(name="signInFrequency")
    def sign_in_frequency(self) -> Optional[pulumi.Input[int]]:
        """
        Number of days or hours to enforce sign-in frequency. Required when `sign_in_frequency_period` is specified. Due to an API issue, removing this property forces a new resource to be created.
        """
        return pulumi.get(self, "sign_in_frequency")

    @sign_in_frequency.setter
    def sign_in_frequency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "sign_in_frequency", value)

    @property
    @pulumi.getter(name="signInFrequencyPeriod")
    def sign_in_frequency_period(self) -> Optional[pulumi.Input[str]]:
        """
        The time period to enforce sign-in frequency. Possible values are: `hours` or `days`. Required when `sign_in_frequency_period` is specified. Due to an API issue, removing this property forces a new resource to be created.
        """
        return pulumi.get(self, "sign_in_frequency_period")

    @sign_in_frequency_period.setter
    def sign_in_frequency_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sign_in_frequency_period", value)


@pulumi.input_type
class CustomDirectoryRolePermissionArgs:
    def __init__(__self__, *,
                 allowed_resource_actions: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_resource_actions: A set of tasks that can be performed on a resource. For more information, see the [Permissions Reference](https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference) documentation.
        """
        CustomDirectoryRolePermissionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_resource_actions=allowed_resource_actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_resource_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allowed_resource_actions", allowed_resource_actions)

    @property
    @pulumi.getter(name="allowedResourceActions")
    def allowed_resource_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A set of tasks that can be performed on a resource. For more information, see the [Permissions Reference](https://docs.microsoft.com/en-us/azure/active-directory/roles/permissions-reference) documentation.
        """
        return pulumi.get(self, "allowed_resource_actions")

    @allowed_resource_actions.setter
    def allowed_resource_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_resource_actions", value)


@pulumi.input_type
class GroupDynamicMembershipArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 rule: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] enabled: Whether rule processing is "On" (true) or "Paused" (false).
        :param pulumi.Input[str] rule: The rule that determines membership of this group. For more information, see official documentation on [membership rules syntax](https://docs.microsoft.com/en-gb/azure/active-directory/enterprise-users/groups-dynamic-membership).
               
               > **Dynamic Group Memberships** Remember to include `DynamicMembership` in the set of `types` for the group when configuring a dynamic membership rule. Dynamic membership is a premium feature which requires an Azure Active Directory P1 or P2 license.
        """
        GroupDynamicMembershipArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            rule=rule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             rule: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        _setter("rule", rule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether rule processing is "On" (true) or "Paused" (false).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The rule that determines membership of this group. For more information, see official documentation on [membership rules syntax](https://docs.microsoft.com/en-gb/azure/active-directory/enterprise-users/groups-dynamic-membership).

        > **Dynamic Group Memberships** Remember to include `DynamicMembership` in the set of `types` for the group when configuring a dynamic membership rule. Dynamic membership is a premium feature which requires an Azure Active Directory P1 or P2 license.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)


@pulumi.input_type
class InvitationMessageArgs:
    def __init__(__self__, *,
                 additional_recipients: Optional[pulumi.Input[str]] = None,
                 body: Optional[pulumi.Input[str]] = None,
                 language: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] additional_recipients: Email addresses of additional recipients the invitation message should be sent to. Only 1 additional recipient is currently supported by Azure.
        :param pulumi.Input[str] body: Customized message body you want to send if you don't want to send the default message. Cannot be specified with `language`.
        :param pulumi.Input[str] language: The language you want to send the default message in. The value specified must be in ISO 639 format. Defaults to `en-US`. Cannot be specified with `body`.
        """
        InvitationMessageArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_recipients=additional_recipients,
            body=body,
            language=language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_recipients: Optional[pulumi.Input[str]] = None,
             body: Optional[pulumi.Input[str]] = None,
             language: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_recipients is not None:
            _setter("additional_recipients", additional_recipients)
        if body is not None:
            _setter("body", body)
        if language is not None:
            _setter("language", language)

    @property
    @pulumi.getter(name="additionalRecipients")
    def additional_recipients(self) -> Optional[pulumi.Input[str]]:
        """
        Email addresses of additional recipients the invitation message should be sent to. Only 1 additional recipient is currently supported by Azure.
        """
        return pulumi.get(self, "additional_recipients")

    @additional_recipients.setter
    def additional_recipients(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_recipients", value)

    @property
    @pulumi.getter
    def body(self) -> Optional[pulumi.Input[str]]:
        """
        Customized message body you want to send if you don't want to send the default message. Cannot be specified with `language`.
        """
        return pulumi.get(self, "body")

    @body.setter
    def body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body", value)

    @property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[str]]:
        """
        The language you want to send the default message in. The value specified must be in ISO 639 format. Defaults to `en-US`. Cannot be specified with `body`.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "language", value)


@pulumi.input_type
class NamedLocationCountryArgs:
    def __init__(__self__, *,
                 countries_and_regions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 include_unknown_countries_and_regions: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] countries_and_regions: List of countries and/or regions in two-letter format specified by ISO 3166-2.
        :param pulumi.Input[bool] include_unknown_countries_and_regions: Whether IP addresses that don't map to a country or region should be included in the named location. Defaults to `false`.
        """
        NamedLocationCountryArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            countries_and_regions=countries_and_regions,
            include_unknown_countries_and_regions=include_unknown_countries_and_regions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             countries_and_regions: pulumi.Input[Sequence[pulumi.Input[str]]],
             include_unknown_countries_and_regions: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("countries_and_regions", countries_and_regions)
        if include_unknown_countries_and_regions is not None:
            _setter("include_unknown_countries_and_regions", include_unknown_countries_and_regions)

    @property
    @pulumi.getter(name="countriesAndRegions")
    def countries_and_regions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of countries and/or regions in two-letter format specified by ISO 3166-2.
        """
        return pulumi.get(self, "countries_and_regions")

    @countries_and_regions.setter
    def countries_and_regions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "countries_and_regions", value)

    @property
    @pulumi.getter(name="includeUnknownCountriesAndRegions")
    def include_unknown_countries_and_regions(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether IP addresses that don't map to a country or region should be included in the named location. Defaults to `false`.
        """
        return pulumi.get(self, "include_unknown_countries_and_regions")

    @include_unknown_countries_and_regions.setter
    def include_unknown_countries_and_regions(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_unknown_countries_and_regions", value)


@pulumi.input_type
class NamedLocationIpArgs:
    def __init__(__self__, *,
                 ip_ranges: pulumi.Input[Sequence[pulumi.Input[str]]],
                 trusted: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_ranges: List of IP address ranges in IPv4 CIDR format (e.g. `1.2.3.4/32`) or any allowable IPv6 format from IETF RFC596.
        :param pulumi.Input[bool] trusted: Whether the named location is trusted. Defaults to `false`.
        """
        NamedLocationIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_ranges=ip_ranges,
            trusted=trusted,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_ranges: pulumi.Input[Sequence[pulumi.Input[str]]],
             trusted: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip_ranges", ip_ranges)
        if trusted is not None:
            _setter("trusted", trusted)

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of IP address ranges in IPv4 CIDR format (e.g. `1.2.3.4/32`) or any allowable IPv6 format from IETF RFC596.
        """
        return pulumi.get(self, "ip_ranges")

    @ip_ranges.setter
    def ip_ranges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ip_ranges", value)

    @property
    @pulumi.getter
    def trusted(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the named location is trusted. Defaults to `false`.
        """
        return pulumi.get(self, "trusted")

    @trusted.setter
    def trusted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trusted", value)


@pulumi.input_type
class ServicePrincipalAppRoleArgs:
    def __init__(__self__, *,
                 allowed_member_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_member_types: Specifies whether this app role definition can be assigned to users and groups, or to other applications (that are accessing this application in a standalone scenario). Possible values are: `User` and `Application`, or both.
        :param pulumi.Input[str] description: A description of the service principal provided for internal end-users.
        :param pulumi.Input[str] display_name: Display name for the app role that appears during app role assignment and in consent experiences.
        :param pulumi.Input[bool] enabled: Specifies whether the permission scope is enabled.
        :param pulumi.Input[str] id: The unique identifier of the delegated permission.
        :param pulumi.Input[str] value: The value that is used for the `scp` claim in OAuth 2.0 access tokens.
        """
        ServicePrincipalAppRoleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_member_types=allowed_member_types,
            description=description,
            display_name=display_name,
            enabled=enabled,
            id=id,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_member_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             description: Optional[pulumi.Input[str]] = None,
             display_name: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allowed_member_types is not None:
            _setter("allowed_member_types", allowed_member_types)
        if description is not None:
            _setter("description", description)
        if display_name is not None:
            _setter("display_name", display_name)
        if enabled is not None:
            _setter("enabled", enabled)
        if id is not None:
            _setter("id", id)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="allowedMemberTypes")
    def allowed_member_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies whether this app role definition can be assigned to users and groups, or to other applications (that are accessing this application in a standalone scenario). Possible values are: `User` and `Application`, or both.
        """
        return pulumi.get(self, "allowed_member_types")

    @allowed_member_types.setter
    def allowed_member_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_member_types", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the service principal provided for internal end-users.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name for the app role that appears during app role assignment and in consent experiences.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the permission scope is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the delegated permission.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that is used for the `scp` claim in OAuth 2.0 access tokens.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServicePrincipalFeatureArgs:
    def __init__(__self__, *,
                 custom_single_sign_on_app: Optional[pulumi.Input[bool]] = None,
                 enterprise_application: Optional[pulumi.Input[bool]] = None,
                 gallery_application: Optional[pulumi.Input[bool]] = None,
                 visible_to_users: Optional[pulumi.Input[bool]] = None):
        ServicePrincipalFeatureArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_single_sign_on_app=custom_single_sign_on_app,
            enterprise_application=enterprise_application,
            gallery_application=gallery_application,
            visible_to_users=visible_to_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_single_sign_on_app: Optional[pulumi.Input[bool]] = None,
             enterprise_application: Optional[pulumi.Input[bool]] = None,
             gallery_application: Optional[pulumi.Input[bool]] = None,
             visible_to_users: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_single_sign_on_app is not None:
            _setter("custom_single_sign_on_app", custom_single_sign_on_app)
        if enterprise_application is not None:
            _setter("enterprise_application", enterprise_application)
        if gallery_application is not None:
            _setter("gallery_application", gallery_application)
        if visible_to_users is not None:
            _setter("visible_to_users", visible_to_users)

    @property
    @pulumi.getter(name="customSingleSignOnApp")
    def custom_single_sign_on_app(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "custom_single_sign_on_app")

    @custom_single_sign_on_app.setter
    def custom_single_sign_on_app(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_single_sign_on_app", value)

    @property
    @pulumi.getter(name="enterpriseApplication")
    def enterprise_application(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enterprise_application")

    @enterprise_application.setter
    def enterprise_application(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enterprise_application", value)

    @property
    @pulumi.getter(name="galleryApplication")
    def gallery_application(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "gallery_application")

    @gallery_application.setter
    def gallery_application(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gallery_application", value)

    @property
    @pulumi.getter(name="visibleToUsers")
    def visible_to_users(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "visible_to_users")

    @visible_to_users.setter
    def visible_to_users(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "visible_to_users", value)


@pulumi.input_type
class ServicePrincipalFeatureTagArgs:
    def __init__(__self__, *,
                 custom_single_sign_on: Optional[pulumi.Input[bool]] = None,
                 enterprise: Optional[pulumi.Input[bool]] = None,
                 gallery: Optional[pulumi.Input[bool]] = None,
                 hide: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] custom_single_sign_on: Whether this service principal represents a custom SAML application. Enabling this will assign the `WindowsAzureActiveDirectoryCustomSingleSignOnApplication` tag. Defaults to `false`.
        :param pulumi.Input[bool] enterprise: Whether this service principal represents an Enterprise Application. Enabling this will assign the `WindowsAzureActiveDirectoryIntegratedApp` tag. Defaults to `false`.
        :param pulumi.Input[bool] gallery: Whether this service principal represents a gallery application. Enabling this will assign the `WindowsAzureActiveDirectoryGalleryApplicationNonPrimaryV1` tag. Defaults to `false`.
        :param pulumi.Input[bool] hide: Whether this app is invisible to users in My Apps and Office 365 Launcher. Enabling this will assign the `HideApp` tag. Defaults to `false`.
        """
        ServicePrincipalFeatureTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_single_sign_on=custom_single_sign_on,
            enterprise=enterprise,
            gallery=gallery,
            hide=hide,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_single_sign_on: Optional[pulumi.Input[bool]] = None,
             enterprise: Optional[pulumi.Input[bool]] = None,
             gallery: Optional[pulumi.Input[bool]] = None,
             hide: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_single_sign_on is not None:
            _setter("custom_single_sign_on", custom_single_sign_on)
        if enterprise is not None:
            _setter("enterprise", enterprise)
        if gallery is not None:
            _setter("gallery", gallery)
        if hide is not None:
            _setter("hide", hide)

    @property
    @pulumi.getter(name="customSingleSignOn")
    def custom_single_sign_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this service principal represents a custom SAML application. Enabling this will assign the `WindowsAzureActiveDirectoryCustomSingleSignOnApplication` tag. Defaults to `false`.
        """
        return pulumi.get(self, "custom_single_sign_on")

    @custom_single_sign_on.setter
    def custom_single_sign_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "custom_single_sign_on", value)

    @property
    @pulumi.getter
    def enterprise(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this service principal represents an Enterprise Application. Enabling this will assign the `WindowsAzureActiveDirectoryIntegratedApp` tag. Defaults to `false`.
        """
        return pulumi.get(self, "enterprise")

    @enterprise.setter
    def enterprise(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enterprise", value)

    @property
    @pulumi.getter
    def gallery(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this service principal represents a gallery application. Enabling this will assign the `WindowsAzureActiveDirectoryGalleryApplicationNonPrimaryV1` tag. Defaults to `false`.
        """
        return pulumi.get(self, "gallery")

    @gallery.setter
    def gallery(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gallery", value)

    @property
    @pulumi.getter
    def hide(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this app is invisible to users in My Apps and Office 365 Launcher. Enabling this will assign the `HideApp` tag. Defaults to `false`.
        """
        return pulumi.get(self, "hide")

    @hide.setter
    def hide(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide", value)


@pulumi.input_type
class ServicePrincipalOauth2PermissionScopeArgs:
    def __init__(__self__, *,
                 admin_consent_description: Optional[pulumi.Input[str]] = None,
                 admin_consent_display_name: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 user_consent_description: Optional[pulumi.Input[str]] = None,
                 user_consent_display_name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] admin_consent_description: Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
        :param pulumi.Input[str] admin_consent_display_name: Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
        :param pulumi.Input[bool] enabled: Specifies whether the permission scope is enabled.
        :param pulumi.Input[str] id: The unique identifier of the delegated permission.
        :param pulumi.Input[str] type: Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Possible values are `User` or `Admin`.
        :param pulumi.Input[str] user_consent_description: Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
        :param pulumi.Input[str] user_consent_display_name: Display name for the delegated permission that appears in the end user consent experience.
        :param pulumi.Input[str] value: The value that is used for the `scp` claim in OAuth 2.0 access tokens.
        """
        ServicePrincipalOauth2PermissionScopeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_consent_description=admin_consent_description,
            admin_consent_display_name=admin_consent_display_name,
            enabled=enabled,
            id=id,
            type=type,
            user_consent_description=user_consent_description,
            user_consent_display_name=user_consent_display_name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_consent_description: Optional[pulumi.Input[str]] = None,
             admin_consent_display_name: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             user_consent_description: Optional[pulumi.Input[str]] = None,
             user_consent_display_name: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_consent_description is not None:
            _setter("admin_consent_description", admin_consent_description)
        if admin_consent_display_name is not None:
            _setter("admin_consent_display_name", admin_consent_display_name)
        if enabled is not None:
            _setter("enabled", enabled)
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)
        if user_consent_description is not None:
            _setter("user_consent_description", user_consent_description)
        if user_consent_display_name is not None:
            _setter("user_consent_display_name", user_consent_display_name)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="adminConsentDescription")
    def admin_consent_description(self) -> Optional[pulumi.Input[str]]:
        """
        Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
        """
        return pulumi.get(self, "admin_consent_description")

    @admin_consent_description.setter
    def admin_consent_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_consent_description", value)

    @property
    @pulumi.getter(name="adminConsentDisplayName")
    def admin_consent_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
        """
        return pulumi.get(self, "admin_consent_display_name")

    @admin_consent_display_name.setter
    def admin_consent_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_consent_display_name", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the permission scope is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The unique identifier of the delegated permission.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Possible values are `User` or `Admin`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userConsentDescription")
    def user_consent_description(self) -> Optional[pulumi.Input[str]]:
        """
        Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
        """
        return pulumi.get(self, "user_consent_description")

    @user_consent_description.setter
    def user_consent_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_consent_description", value)

    @property
    @pulumi.getter(name="userConsentDisplayName")
    def user_consent_display_name(self) -> Optional[pulumi.Input[str]]:
        """
        Display name for the delegated permission that appears in the end user consent experience.
        """
        return pulumi.get(self, "user_consent_display_name")

    @user_consent_display_name.setter
    def user_consent_display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_consent_display_name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that is used for the `scp` claim in OAuth 2.0 access tokens.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServicePrincipalSamlSingleSignOnArgs:
    def __init__(__self__, *,
                 relay_state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] relay_state: The relative URI the service provider would redirect to after completion of the single sign-on flow.
        """
        ServicePrincipalSamlSingleSignOnArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            relay_state=relay_state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             relay_state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if relay_state is not None:
            _setter("relay_state", relay_state)

    @property
    @pulumi.getter(name="relayState")
    def relay_state(self) -> Optional[pulumi.Input[str]]:
        """
        The relative URI the service provider would redirect to after completion of the single sign-on flow.
        """
        return pulumi.get(self, "relay_state")

    @relay_state.setter
    def relay_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relay_state", value)


@pulumi.input_type
class SynchronizationJobScheduleArgs:
    def __init__(__self__, *,
                 expiration: Optional[pulumi.Input[str]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expiration: Date and time when this job will expire, formatted as an RFC3339 date string (e.g. `2018-01-01T01:02:03Z`).
        :param pulumi.Input[str] interval: The interval between synchronization iterations ISO8601. E.g. PT40M run every 40 minutes.
        :param pulumi.Input[str] state: State of the job.
        """
        SynchronizationJobScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expiration=expiration,
            interval=interval,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expiration: Optional[pulumi.Input[str]] = None,
             interval: Optional[pulumi.Input[str]] = None,
             state: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if expiration is not None:
            _setter("expiration", expiration)
        if interval is not None:
            _setter("interval", interval)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Date and time when this job will expire, formatted as an RFC3339 date string (e.g. `2018-01-01T01:02:03Z`).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The interval between synchronization iterations ISO8601. E.g. PT40M run every 40 minutes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the job.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class SynchronizationSecretCredentialArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the secret.
        :param pulumi.Input[str] value: The value of the secret.
        """
        SynchronizationSecretCredentialArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the secret.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


