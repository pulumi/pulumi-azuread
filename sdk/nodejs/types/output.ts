// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface ApplicationApi {
    /**
     * A set of application IDs (client IDs), used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app.
     */
    knownClientApplications?: string[];
    /**
     * Allows an application to use claims mapping without specifying a custom signing key. Defaults to `false`.
     */
    mappedClaimsEnabled?: boolean;
    /**
     * One or more `oauth2PermissionScope` blocks as documented below, to describe delegated permissions exposed by the web API represented by this application.
     */
    oauth2PermissionScopes?: outputs.ApplicationApiOauth2PermissionScope[];
    /**
     * The access token version expected by this resource. Must be one of `1` or `2`, and must be `2` when `signInAudience` is either `AzureADandPersonalMicrosoftAccount` or `PersonalMicrosoftAccount` Defaults to `1`.
     */
    requestedAccessTokenVersion?: number;
}

export interface ApplicationApiOauth2PermissionScope {
    /**
     * Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDescription?: string;
    /**
     * Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDisplayName?: string;
    /**
     * Determines if the permission scope is enabled. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * The unique identifier of the delegated permission. Must be a valid UUID.
     */
    id: string;
    /**
     * Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Defaults to `User`. Possible values are `User` or `Admin`.
     */
    type?: string;
    /**
     * Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
     */
    userConsentDescription?: string;
    /**
     * Display name for the delegated permission that appears in the end user consent experience.
     */
    userConsentDisplayName?: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens.
     */
    value?: string;
}

export interface ApplicationAppRole {
    /**
     * Specifies whether this app role definition can be assigned to users and groups by setting to `User`, or to other applications (that are accessing this application in a standalone scenario) by setting to `Application`, or to both.
     */
    allowedMemberTypes: string[];
    /**
     * Description of the app role that appears when the role is being assigned and, if the role functions as an application permissions, during the consent experiences.
     */
    description: string;
    /**
     * Display name for the app role that appears during app role assignment and in consent experiences.
     */
    displayName: string;
    /**
     * Determines if the app role is enabled. Defaults to `true`.
     */
    enabled?: boolean;
    /**
     * The unique identifier of the app role. Must be a valid UUID.
     */
    id: string;
    /**
     * The value that is used for the `roles` claim in ID tokens and OAuth 2.0 access tokens that are authenticating an assigned service or user principal.
     */
    value?: string;
}

export interface ApplicationOptionalClaims {
    /**
     * One or more `accessToken` blocks as documented below.
     */
    accessTokens?: outputs.ApplicationOptionalClaimsAccessToken[];
    /**
     * One or more `idToken` blocks as documented below.
     */
    idTokens?: outputs.ApplicationOptionalClaimsIdToken[];
    /**
     * One or more `saml2Token` blocks as documented below.
     */
    saml2Tokens?: outputs.ApplicationOptionalClaimsSaml2Token[];
}

export interface ApplicationOptionalClaimsAccessToken {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface ApplicationOptionalClaimsIdToken {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface ApplicationOptionalClaimsSaml2Token {
    /**
     * List of additional properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface ApplicationPublicClient {
    /**
     * A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris?: string[];
}

export interface ApplicationRequiredResourceAccess {
    /**
     * A collection of `resourceAccess` blocks as documented below, describing OAuth2.0 permission scopes and app roles that the application requires from the specified resource.
     */
    resourceAccesses: outputs.ApplicationRequiredResourceAccessResourceAccess[];
    /**
     * The unique identifier for the resource that the application requires access to. This should be the Application ID of the target application.
     */
    resourceAppId: string;
}

export interface ApplicationRequiredResourceAccessResourceAccess {
    /**
     * The unique identifier for an app role or OAuth2 permission scope published by the resource application.
     */
    id: string;
    /**
     * Specifies whether the `id` property references an app role or an OAuth2 permission scope. Possible values are `Role` or `Scope`.
     */
    type: string;
}

export interface ApplicationSinglePageApplication {
    /**
     * A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris?: string[];
}

export interface ApplicationWeb {
    /**
     * Home page or landing page of the application.
     */
    homepageUrl?: string;
    /**
     * An `implicitGrant` block as documented above.
     */
    implicitGrant?: outputs.ApplicationWebImplicitGrant;
    /**
     * The URL that will be used by Microsoft's authorization service to sign out a user using front-channel, back-channel or SAML logout protocols.
     */
    logoutUrl?: string;
    /**
     * A set of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris?: string[];
}

export interface ApplicationWebImplicitGrant {
    /**
     * Whether this web application can request an access token using OAuth 2.0 implicit flow.
     */
    accessTokenIssuanceEnabled?: boolean;
    /**
     * Whether this web application can request an ID token using OAuth 2.0 implicit flow.
     */
    idTokenIssuanceEnabled?: boolean;
}

export interface GetApplicationApi {
    /**
     * A set of application IDs (client IDs), used for bundling consent if you have a solution that contains two parts: a client app and a custom web API app.
     */
    knownClientApplications: string[];
    /**
     * Allows an application to use claims mapping without specifying a custom signing key.
     */
    mappedClaimsEnabled: boolean;
    oauth2PermissionScopes: outputs.GetApplicationApiOauth2PermissionScope[];
    /**
     * The access token version expected by this resource. Possible values are `1` or `2`.
     */
    requestedAccessTokenVersion: number;
}

export interface GetApplicationApiOauth2PermissionScope {
    /**
     * Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDescription: string;
    /**
     * Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDisplayName: string;
    /**
     * Determines if the app role is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier for an app role or OAuth2 permission scope published by the resource application.
     */
    id: string;
    /**
     * Specifies whether the `id` property references an app role or an OAuth2 permission scope. Possible values are `Role` or `Scope`.
     */
    type: string;
    /**
     * Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
     */
    userConsentDescription: string;
    /**
     * Display name for the delegated permission that appears in the end user consent experience.
     */
    userConsentDisplayName: string;
    /**
     * The value that is used for the `roles` claim in ID tokens and OAuth 2.0 access tokens that are authenticating an assigned service or user principal.
     */
    value: string;
}

export interface GetApplicationAppRole {
    /**
     * Specifies whether this app role definition can be assigned to users and groups, or to other applications (that are accessing this application in a standalone scenario). Possible values are `User` or `Application`, or both.
     */
    allowedMemberTypes: string[];
    /**
     * Description of the app role that appears when the role is being assigned and, if the role functions as an application permissions, during the consent experiences.
     */
    description: string;
    /**
     * Specifies the display name of the application.
     */
    displayName: string;
    /**
     * Determines if the app role is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier for an app role or OAuth2 permission scope published by the resource application.
     */
    id: string;
    /**
     * The value that is used for the `roles` claim in ID tokens and OAuth 2.0 access tokens that are authenticating an assigned service or user principal.
     */
    value: string;
}

export interface GetApplicationOptionalClaim {
    /**
     * One or more `accessToken` blocks as documented below.
     */
    accessTokens?: outputs.GetApplicationOptionalClaimAccessToken[];
    /**
     * One or more `idToken` blocks as documented below.
     */
    idTokens?: outputs.GetApplicationOptionalClaimIdToken[];
    /**
     * One or more `saml2Token` blocks as documented below.
     */
    saml2Tokens?: outputs.GetApplicationOptionalClaimSaml2Token[];
}

export interface GetApplicationOptionalClaimAccessToken {
    /**
     * List of Additional Properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface GetApplicationOptionalClaimIdToken {
    /**
     * List of Additional Properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface GetApplicationOptionalClaimSaml2Token {
    /**
     * List of Additional Properties of the claim. If a property exists in this list, it modifies the behaviour of the optional claim.
     */
    additionalProperties?: string[];
    /**
     * Whether the claim specified by the client is necessary to ensure a smooth authorization experience.
     */
    essential?: boolean;
    /**
     * The name of the optional claim.
     */
    name: string;
    /**
     * The source of the claim. If `source` is absent, the claim is a predefined optional claim. If `source` is `user`, the value of `name` is the extension property from the user object.
     */
    source?: string;
}

export interface GetApplicationPublicClient {
    /**
     * A list of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris: string[];
}

export interface GetApplicationRequiredResourceAccess {
    /**
     * A collection of `resourceAccess` blocks as documented below, describing OAuth2.0 permission scopes and app roles that the application requires from the specified resource.
     */
    resourceAccesses: outputs.GetApplicationRequiredResourceAccessResourceAccess[];
    /**
     * The unique identifier for the resource that the application requires access to. This is the Application ID of the target application.
     */
    resourceAppId: string;
}

export interface GetApplicationRequiredResourceAccessResourceAccess {
    /**
     * The unique identifier for an app role or OAuth2 permission scope published by the resource application.
     */
    id: string;
    /**
     * Specifies whether the `id` property references an app role or an OAuth2 permission scope. Possible values are `Role` or `Scope`.
     */
    type: string;
}

export interface GetApplicationSinglePageApplication {
    /**
     * A list of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris: string[];
}

export interface GetApplicationWeb {
    /**
     * Home page or landing page of the application.
     */
    homepageUrl: string;
    /**
     * An `implicitGrant` block as documented above.
     */
    implicitGrants: outputs.GetApplicationWebImplicitGrant[];
    /**
     * The URL that will be used by Microsoft's authorization service to sign out a user using front-channel, back-channel or SAML logout protocols.
     */
    logoutUrl: string;
    /**
     * A list of URLs where user tokens are sent for sign-in, or the redirect URIs where OAuth 2.0 authorization codes and access tokens are sent.
     */
    redirectUris: string[];
}

export interface GetApplicationWebImplicitGrant {
    /**
     * Whether this web application can request an access token using OAuth 2.0 implicit flow.
     */
    accessTokenIssuanceEnabled: boolean;
    /**
     * Whether this web application can request an ID token using OAuth 2.0 implicit flow.
     */
    idTokenIssuanceEnabled: boolean;
}

export interface GetDomainsDomain {
    /**
     * Set to `true` to only return domains whose DNS is managed by Microsoft 365. Defaults to `false`.
     */
    adminManaged: boolean;
    /**
     * The authentication type of the domain. Possible values include `Managed` or `Federated`.
     */
    authenticationType: string;
    /**
     * Whether this is the default domain that is used for user creation.
     */
    default: boolean;
    /**
     * The name of the domain.
     */
    domainName: string;
    /**
     * Whether this is the initial domain created by Azure Active Directory.
     */
    initial: boolean;
    /**
     * Whether the domain is a verified root domain (not a subdomain).
     */
    root: boolean;
    /**
     * A list of capabilities / services supported by the domain. Possible values include `Email`, `Sharepoint`, `EmailInternalRelayOnly`, `OfficeCommunicationsOnline`, `SharePointDefaultDomain`, `FullRedelegation`, `SharePointPublic`, `OrgIdAuthentication`, `Yammer` and `Intune`.
     */
    supportedServices: string[];
    /**
     * Whether the domain has completed domain ownership verification.
     */
    verified: boolean;
}

export interface GetServicePrincipalAppRole {
    /**
     * Specifies whether this app role definition can be assigned to users and groups, or to other applications (that are accessing this application in daemon service scenarios). Possible values are: `User` and `Application`, or both.
     */
    allowedMemberTypes: string[];
    /**
     * Permission help text that appears in the admin app assignment and consent experiences.
     */
    description: string;
    /**
     * The display name of the application associated with this service principal.
     */
    displayName: string;
    /**
     * Determines if the permission scope is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier of the delegated permission. Must be a valid UUID.
     */
    id: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens.
     */
    value: string;
}

export interface GetServicePrincipalOauth2PermissionScope {
    /**
     * Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDescription: string;
    /**
     * Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDisplayName: string;
    /**
     * Determines if the permission scope is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier of the delegated permission. Must be a valid UUID.
     */
    id: string;
    /**
     * Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Possible values are `User` or `Admin`.
     */
    type: string;
    /**
     * Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
     */
    userConsentDescription: string;
    /**
     * Display name for the delegated permission that appears in the end user consent experience.
     */
    userConsentDisplayName: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens.
     */
    value: string;
}

export interface GetUsersUser {
    /**
     * Whether or not the account is enabled.
     */
    accountEnabled: boolean;
    /**
     * The display name of the user.
     */
    displayName: string;
    /**
     * The primary email address of the user.
     */
    mail: string;
    /**
     * The email alias of the user.
     */
    mailNickname: string;
    /**
     * The object ID of the user.
     */
    objectId: string;
    /**
     * The value used to associate an on-premises Active Directory user account with their Azure AD user object.
     */
    onpremisesImmutableId: string;
    /**
     * The on-premise SAM account name of the user.
     */
    onpremisesSamAccountName: string;
    /**
     * The on-premise user principal name of the user.
     */
    onpremisesUserPrincipalName: string;
    /**
     * The usage location of the user.
     */
    usageLocation: string;
    /**
     * The user principal name (UPN) of the user.
     */
    userPrincipalName: string;
}

export interface InvitationMessage {
    /**
     * Email addresses of additional recipients the invitation message should be sent to. Only 1 additional recipient is currently supported by Azure.
     */
    additionalRecipients?: string;
    /**
     * Customized message body you want to send if you don't want to send the default message. Cannot be specified with `language`.
     */
    body?: string;
    /**
     * The language you want to send the default message in. The value specified must be in ISO 639 format. Defaults to `en-US`. Cannot be specified with `body`.
     */
    language?: string;
}

export interface ServicePrincipalAppRole {
    /**
     * Specifies whether this app role definition can be assigned to users and groups, or to other applications (that are accessing this application in a standalone scenario). Possible values are: `User` and `Application`, or both.
     */
    allowedMemberTypes: string[];
    /**
     * A description of the service principal provided for internal end-users.
     */
    description: string;
    /**
     * Display name for the app role that appears during app role assignment and in consent experiences.
     */
    displayName: string;
    /**
     * Specifies whether the permission scope is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier of the delegated permission.
     */
    id: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens.
     */
    value: string;
}

export interface ServicePrincipalOauth2PermissionScope {
    /**
     * Delegated permission description that appears in all tenant-wide admin consent experiences, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDescription: string;
    /**
     * Display name for the delegated permission, intended to be read by an administrator granting the permission on behalf of all users.
     */
    adminConsentDisplayName: string;
    /**
     * Specifies whether the permission scope is enabled.
     */
    enabled: boolean;
    /**
     * The unique identifier of the delegated permission.
     */
    id: string;
    /**
     * Whether this delegated permission should be considered safe for non-admin users to consent to on behalf of themselves, or whether an administrator should be required for consent to the permissions. Possible values are `User` or `Admin`.
     */
    type: string;
    /**
     * Delegated permission description that appears in the end user consent experience, intended to be read by a user consenting on their own behalf.
     */
    userConsentDescription: string;
    /**
     * Display name for the delegated permission that appears in the end user consent experience.
     */
    userConsentDisplayName: string;
    /**
     * The value that is used for the `scp` claim in OAuth 2.0 access tokens.
     */
    value: string;
}

